import {
  __commonJS
} from "./chunk-BUSYA2B4.js";

// node_modules/katex/src/ParseError.js
var require_ParseError = __commonJS({
  "node_modules/katex/src/ParseError.js"(exports, module) {
    function ParseError(message, lexer, position) {
      var error = "KaTeX parse error: " + message;
      if (lexer !== void 0 && position !== void 0) {
        error += " at position " + position + ": ";
        var input = lexer._input;
        input = input.slice(0, position) + "Ì²" + input.slice(position);
        var begin = Math.max(0, position - 15);
        var end = position + 15;
        error += input.slice(begin, end);
      }
      var self = new Error(error);
      self.name = "ParseError";
      self.__proto__ = ParseError.prototype;
      self.position = position;
      return self;
    }
    ParseError.prototype.__proto__ = Error.prototype;
    module.exports = ParseError;
  }
});

// node_modules/katex/src/Settings.js
var require_Settings = __commonJS({
  "node_modules/katex/src/Settings.js"(exports, module) {
    function get(option, defaultValue) {
      return option === void 0 ? defaultValue : option;
    }
    function Settings(options) {
      options = options || {};
      this.displayMode = get(options.displayMode, false);
      this.throwOnError = get(options.throwOnError, true);
      this.errorColor = get(options.errorColor, "#cc0000");
    }
    module.exports = Settings;
  }
});

// node_modules/katex/src/Style.js
var require_Style = __commonJS({
  "node_modules/katex/src/Style.js"(exports, module) {
    function Style(id, size, multiplier, cramped) {
      this.id = id;
      this.size = size;
      this.cramped = cramped;
      this.sizeMultiplier = multiplier;
    }
    Style.prototype.sup = function() {
      return styles[sup[this.id]];
    };
    Style.prototype.sub = function() {
      return styles[sub[this.id]];
    };
    Style.prototype.fracNum = function() {
      return styles[fracNum[this.id]];
    };
    Style.prototype.fracDen = function() {
      return styles[fracDen[this.id]];
    };
    Style.prototype.cramp = function() {
      return styles[cramp[this.id]];
    };
    Style.prototype.cls = function() {
      return sizeNames[this.size] + (this.cramped ? " cramped" : " uncramped");
    };
    Style.prototype.reset = function() {
      return resetNames[this.size];
    };
    var D = 0;
    var Dc = 1;
    var T = 2;
    var Tc = 3;
    var S = 4;
    var Sc = 5;
    var SS = 6;
    var SSc = 7;
    var sizeNames = [
      "displaystyle textstyle",
      "textstyle",
      "scriptstyle",
      "scriptscriptstyle"
    ];
    var resetNames = [
      "reset-textstyle",
      "reset-textstyle",
      "reset-scriptstyle",
      "reset-scriptscriptstyle"
    ];
    var styles = [
      new Style(D, 0, 1, false),
      new Style(Dc, 0, 1, true),
      new Style(T, 1, 1, false),
      new Style(Tc, 1, 1, true),
      new Style(S, 2, 0.7, false),
      new Style(Sc, 2, 0.7, true),
      new Style(SS, 3, 0.5, false),
      new Style(SSc, 3, 0.5, true)
    ];
    var sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];
    var sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
    var fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc];
    var fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
    var cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];
    module.exports = {
      DISPLAY: styles[D],
      TEXT: styles[T],
      SCRIPT: styles[S],
      SCRIPTSCRIPT: styles[SS]
    };
  }
});

// node_modules/katex/src/utils.js
var require_utils = __commonJS({
  "node_modules/katex/src/utils.js"(exports, module) {
    var nativeIndexOf = Array.prototype.indexOf;
    var indexOf = function(list, elem) {
      if (list == null) {
        return -1;
      }
      if (nativeIndexOf && list.indexOf === nativeIndexOf) {
        return list.indexOf(elem);
      }
      var i = 0;
      var l = list.length;
      for (; i < l; i++) {
        if (list[i] === elem) {
          return i;
        }
      }
      return -1;
    };
    var contains = function(list, elem) {
      return indexOf(list, elem) !== -1;
    };
    var deflt = function(setting, defaultIfUndefined) {
      return setting === void 0 ? defaultIfUndefined : setting;
    };
    var uppercase = /([A-Z])/g;
    var hyphenate = function(str) {
      return str.replace(uppercase, "-$1").toLowerCase();
    };
    var ESCAPE_LOOKUP = {
      "&": "&amp;",
      ">": "&gt;",
      "<": "&lt;",
      '"': "&quot;",
      "'": "&#x27;"
    };
    var ESCAPE_REGEX = /[&><"']/g;
    function escaper(match) {
      return ESCAPE_LOOKUP[match];
    }
    function escape(text) {
      return ("" + text).replace(ESCAPE_REGEX, escaper);
    }
    var setTextContent;
    if (typeof document !== "undefined") {
      testNode = document.createElement("span");
      if ("textContent" in testNode) {
        setTextContent = function(node, text) {
          node.textContent = text;
        };
      } else {
        setTextContent = function(node, text) {
          node.innerText = text;
        };
      }
    }
    var testNode;
    function clearNode(node) {
      setTextContent(node, "");
    }
    module.exports = {
      contains,
      deflt,
      escape,
      hyphenate,
      indexOf,
      setTextContent,
      clearNode
    };
  }
});

// node_modules/katex/src/domTree.js
var require_domTree = __commonJS({
  "node_modules/katex/src/domTree.js"(exports, module) {
    var utils = require_utils();
    var createClass = function(classes) {
      classes = classes.slice();
      for (var i = classes.length - 1; i >= 0; i--) {
        if (!classes[i]) {
          classes.splice(i, 1);
        }
      }
      return classes.join(" ");
    };
    function span(classes, children, height, depth, maxFontSize, style) {
      this.classes = classes || [];
      this.children = children || [];
      this.height = height || 0;
      this.depth = depth || 0;
      this.maxFontSize = maxFontSize || 0;
      this.style = style || {};
      this.attributes = {};
    }
    span.prototype.setAttribute = function(attribute, value) {
      this.attributes[attribute] = value;
    };
    span.prototype.toNode = function() {
      var span2 = document.createElement("span");
      span2.className = createClass(this.classes);
      for (var style in this.style) {
        if (Object.prototype.hasOwnProperty.call(this.style, style)) {
          span2.style[style] = this.style[style];
        }
      }
      for (var attr in this.attributes) {
        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
          span2.setAttribute(attr, this.attributes[attr]);
        }
      }
      for (var i = 0; i < this.children.length; i++) {
        span2.appendChild(this.children[i].toNode());
      }
      return span2;
    };
    span.prototype.toMarkup = function() {
      var markup = "<span";
      if (this.classes.length) {
        markup += ' class="';
        markup += utils.escape(createClass(this.classes));
        markup += '"';
      }
      var styles = "";
      for (var style in this.style) {
        if (this.style.hasOwnProperty(style)) {
          styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
        }
      }
      if (styles) {
        markup += ' style="' + utils.escape(styles) + '"';
      }
      for (var attr in this.attributes) {
        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
          markup += " " + attr + '="';
          markup += utils.escape(this.attributes[attr]);
          markup += '"';
        }
      }
      markup += ">";
      for (var i = 0; i < this.children.length; i++) {
        markup += this.children[i].toMarkup();
      }
      markup += "</span>";
      return markup;
    };
    function documentFragment(children, height, depth, maxFontSize) {
      this.children = children || [];
      this.height = height || 0;
      this.depth = depth || 0;
      this.maxFontSize = maxFontSize || 0;
    }
    documentFragment.prototype.toNode = function() {
      var frag = document.createDocumentFragment();
      for (var i = 0; i < this.children.length; i++) {
        frag.appendChild(this.children[i].toNode());
      }
      return frag;
    };
    documentFragment.prototype.toMarkup = function() {
      var markup = "";
      for (var i = 0; i < this.children.length; i++) {
        markup += this.children[i].toMarkup();
      }
      return markup;
    };
    function symbolNode(value, height, depth, italic, skew, classes, style) {
      this.value = value || "";
      this.height = height || 0;
      this.depth = depth || 0;
      this.italic = italic || 0;
      this.skew = skew || 0;
      this.classes = classes || [];
      this.style = style || {};
      this.maxFontSize = 0;
    }
    symbolNode.prototype.toNode = function() {
      var node = document.createTextNode(this.value);
      var span2 = null;
      if (this.italic > 0) {
        span2 = document.createElement("span");
        span2.style.marginRight = this.italic + "em";
      }
      if (this.classes.length > 0) {
        span2 = span2 || document.createElement("span");
        span2.className = createClass(this.classes);
      }
      for (var style in this.style) {
        if (this.style.hasOwnProperty(style)) {
          span2 = span2 || document.createElement("span");
          span2.style[style] = this.style[style];
        }
      }
      if (span2) {
        span2.appendChild(node);
        return span2;
      } else {
        return node;
      }
    };
    symbolNode.prototype.toMarkup = function() {
      var needsSpan = false;
      var markup = "<span";
      if (this.classes.length) {
        needsSpan = true;
        markup += ' class="';
        markup += utils.escape(createClass(this.classes));
        markup += '"';
      }
      var styles = "";
      if (this.italic > 0) {
        styles += "margin-right:" + this.italic + "em;";
      }
      for (var style in this.style) {
        if (this.style.hasOwnProperty(style)) {
          styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
        }
      }
      if (styles) {
        needsSpan = true;
        markup += ' style="' + utils.escape(styles) + '"';
      }
      var escaped = utils.escape(this.value);
      if (needsSpan) {
        markup += ">";
        markup += escaped;
        markup += "</span>";
        return markup;
      } else {
        return escaped;
      }
    };
    module.exports = {
      span,
      documentFragment,
      symbolNode
    };
  }
});

// node_modules/katex/src/fontMetricsData.js
var require_fontMetricsData = __commonJS({
  "node_modules/katex/src/fontMetricsData.js"(exports, module) {
    module.exports = {
      "AMS-Regular": {
        "65": [0, 0.68889, 0, 0],
        "66": [0, 0.68889, 0, 0],
        "67": [0, 0.68889, 0, 0],
        "68": [0, 0.68889, 0, 0],
        "69": [0, 0.68889, 0, 0],
        "70": [0, 0.68889, 0, 0],
        "71": [0, 0.68889, 0, 0],
        "72": [0, 0.68889, 0, 0],
        "73": [0, 0.68889, 0, 0],
        "74": [0.16667, 0.68889, 0, 0],
        "75": [0, 0.68889, 0, 0],
        "76": [0, 0.68889, 0, 0],
        "77": [0, 0.68889, 0, 0],
        "78": [0, 0.68889, 0, 0],
        "79": [0.16667, 0.68889, 0, 0],
        "80": [0, 0.68889, 0, 0],
        "81": [0.16667, 0.68889, 0, 0],
        "82": [0, 0.68889, 0, 0],
        "83": [0, 0.68889, 0, 0],
        "84": [0, 0.68889, 0, 0],
        "85": [0, 0.68889, 0, 0],
        "86": [0, 0.68889, 0, 0],
        "87": [0, 0.68889, 0, 0],
        "88": [0, 0.68889, 0, 0],
        "89": [0, 0.68889, 0, 0],
        "90": [0, 0.68889, 0, 0],
        "107": [0, 0.68889, 0, 0],
        "165": [0, 0.675, 0.025, 0],
        "174": [0.15559, 0.69224, 0, 0],
        "240": [0, 0.68889, 0, 0],
        "295": [0, 0.68889, 0, 0],
        "710": [0, 0.825, 0, 0],
        "732": [0, 0.9, 0, 0],
        "770": [0, 0.825, 0, 0],
        "771": [0, 0.9, 0, 0],
        "989": [0.08167, 0.58167, 0, 0],
        "1008": [0, 0.43056, 0.04028, 0],
        "8245": [0, 0.54986, 0, 0],
        "8463": [0, 0.68889, 0, 0],
        "8487": [0, 0.68889, 0, 0],
        "8498": [0, 0.68889, 0, 0],
        "8502": [0, 0.68889, 0, 0],
        "8503": [0, 0.68889, 0, 0],
        "8504": [0, 0.68889, 0, 0],
        "8513": [0, 0.68889, 0, 0],
        "8592": [-0.03598, 0.46402, 0, 0],
        "8594": [-0.03598, 0.46402, 0, 0],
        "8602": [-0.13313, 0.36687, 0, 0],
        "8603": [-0.13313, 0.36687, 0, 0],
        "8606": [0.01354, 0.52239, 0, 0],
        "8608": [0.01354, 0.52239, 0, 0],
        "8610": [0.01354, 0.52239, 0, 0],
        "8611": [0.01354, 0.52239, 0, 0],
        "8619": [0, 0.54986, 0, 0],
        "8620": [0, 0.54986, 0, 0],
        "8621": [-0.13313, 0.37788, 0, 0],
        "8622": [-0.13313, 0.36687, 0, 0],
        "8624": [0, 0.69224, 0, 0],
        "8625": [0, 0.69224, 0, 0],
        "8630": [0, 0.43056, 0, 0],
        "8631": [0, 0.43056, 0, 0],
        "8634": [0.08198, 0.58198, 0, 0],
        "8635": [0.08198, 0.58198, 0, 0],
        "8638": [0.19444, 0.69224, 0, 0],
        "8639": [0.19444, 0.69224, 0, 0],
        "8642": [0.19444, 0.69224, 0, 0],
        "8643": [0.19444, 0.69224, 0, 0],
        "8644": [0.1808, 0.675, 0, 0],
        "8646": [0.1808, 0.675, 0, 0],
        "8647": [0.1808, 0.675, 0, 0],
        "8648": [0.19444, 0.69224, 0, 0],
        "8649": [0.1808, 0.675, 0, 0],
        "8650": [0.19444, 0.69224, 0, 0],
        "8651": [0.01354, 0.52239, 0, 0],
        "8652": [0.01354, 0.52239, 0, 0],
        "8653": [-0.13313, 0.36687, 0, 0],
        "8654": [-0.13313, 0.36687, 0, 0],
        "8655": [-0.13313, 0.36687, 0, 0],
        "8666": [0.13667, 0.63667, 0, 0],
        "8667": [0.13667, 0.63667, 0, 0],
        "8669": [-0.13313, 0.37788, 0, 0],
        "8672": [-0.064, 0.437, 0, 0],
        "8674": [-0.064, 0.437, 0, 0],
        "8705": [0, 0.825, 0, 0],
        "8708": [0, 0.68889, 0, 0],
        "8709": [0.08167, 0.58167, 0, 0],
        "8717": [0, 0.43056, 0, 0],
        "8722": [-0.03598, 0.46402, 0, 0],
        "8724": [0.08198, 0.69224, 0, 0],
        "8726": [0.08167, 0.58167, 0, 0],
        "8733": [0, 0.69224, 0, 0],
        "8736": [0, 0.69224, 0, 0],
        "8737": [0, 0.69224, 0, 0],
        "8738": [0.03517, 0.52239, 0, 0],
        "8739": [0.08167, 0.58167, 0, 0],
        "8740": [0.25142, 0.74111, 0, 0],
        "8741": [0.08167, 0.58167, 0, 0],
        "8742": [0.25142, 0.74111, 0, 0],
        "8756": [0, 0.69224, 0, 0],
        "8757": [0, 0.69224, 0, 0],
        "8764": [-0.13313, 0.36687, 0, 0],
        "8765": [-0.13313, 0.37788, 0, 0],
        "8769": [-0.13313, 0.36687, 0, 0],
        "8770": [-0.03625, 0.46375, 0, 0],
        "8774": [0.30274, 0.79383, 0, 0],
        "8776": [-0.01688, 0.48312, 0, 0],
        "8778": [0.08167, 0.58167, 0, 0],
        "8782": [0.06062, 0.54986, 0, 0],
        "8783": [0.06062, 0.54986, 0, 0],
        "8785": [0.08198, 0.58198, 0, 0],
        "8786": [0.08198, 0.58198, 0, 0],
        "8787": [0.08198, 0.58198, 0, 0],
        "8790": [0, 0.69224, 0, 0],
        "8791": [0.22958, 0.72958, 0, 0],
        "8796": [0.08198, 0.91667, 0, 0],
        "8806": [0.25583, 0.75583, 0, 0],
        "8807": [0.25583, 0.75583, 0, 0],
        "8808": [0.25142, 0.75726, 0, 0],
        "8809": [0.25142, 0.75726, 0, 0],
        "8812": [0.25583, 0.75583, 0, 0],
        "8814": [0.20576, 0.70576, 0, 0],
        "8815": [0.20576, 0.70576, 0, 0],
        "8816": [0.30274, 0.79383, 0, 0],
        "8817": [0.30274, 0.79383, 0, 0],
        "8818": [0.22958, 0.72958, 0, 0],
        "8819": [0.22958, 0.72958, 0, 0],
        "8822": [0.1808, 0.675, 0, 0],
        "8823": [0.1808, 0.675, 0, 0],
        "8828": [0.13667, 0.63667, 0, 0],
        "8829": [0.13667, 0.63667, 0, 0],
        "8830": [0.22958, 0.72958, 0, 0],
        "8831": [0.22958, 0.72958, 0, 0],
        "8832": [0.20576, 0.70576, 0, 0],
        "8833": [0.20576, 0.70576, 0, 0],
        "8840": [0.30274, 0.79383, 0, 0],
        "8841": [0.30274, 0.79383, 0, 0],
        "8842": [0.13597, 0.63597, 0, 0],
        "8843": [0.13597, 0.63597, 0, 0],
        "8847": [0.03517, 0.54986, 0, 0],
        "8848": [0.03517, 0.54986, 0, 0],
        "8858": [0.08198, 0.58198, 0, 0],
        "8859": [0.08198, 0.58198, 0, 0],
        "8861": [0.08198, 0.58198, 0, 0],
        "8862": [0, 0.675, 0, 0],
        "8863": [0, 0.675, 0, 0],
        "8864": [0, 0.675, 0, 0],
        "8865": [0, 0.675, 0, 0],
        "8872": [0, 0.69224, 0, 0],
        "8873": [0, 0.69224, 0, 0],
        "8874": [0, 0.69224, 0, 0],
        "8876": [0, 0.68889, 0, 0],
        "8877": [0, 0.68889, 0, 0],
        "8878": [0, 0.68889, 0, 0],
        "8879": [0, 0.68889, 0, 0],
        "8882": [0.03517, 0.54986, 0, 0],
        "8883": [0.03517, 0.54986, 0, 0],
        "8884": [0.13667, 0.63667, 0, 0],
        "8885": [0.13667, 0.63667, 0, 0],
        "8888": [0, 0.54986, 0, 0],
        "8890": [0.19444, 0.43056, 0, 0],
        "8891": [0.19444, 0.69224, 0, 0],
        "8892": [0.19444, 0.69224, 0, 0],
        "8901": [0, 0.54986, 0, 0],
        "8903": [0.08167, 0.58167, 0, 0],
        "8905": [0.08167, 0.58167, 0, 0],
        "8906": [0.08167, 0.58167, 0, 0],
        "8907": [0, 0.69224, 0, 0],
        "8908": [0, 0.69224, 0, 0],
        "8909": [-0.03598, 0.46402, 0, 0],
        "8910": [0, 0.54986, 0, 0],
        "8911": [0, 0.54986, 0, 0],
        "8912": [0.03517, 0.54986, 0, 0],
        "8913": [0.03517, 0.54986, 0, 0],
        "8914": [0, 0.54986, 0, 0],
        "8915": [0, 0.54986, 0, 0],
        "8916": [0, 0.69224, 0, 0],
        "8918": [0.0391, 0.5391, 0, 0],
        "8919": [0.0391, 0.5391, 0, 0],
        "8920": [0.03517, 0.54986, 0, 0],
        "8921": [0.03517, 0.54986, 0, 0],
        "8922": [0.38569, 0.88569, 0, 0],
        "8923": [0.38569, 0.88569, 0, 0],
        "8926": [0.13667, 0.63667, 0, 0],
        "8927": [0.13667, 0.63667, 0, 0],
        "8928": [0.30274, 0.79383, 0, 0],
        "8929": [0.30274, 0.79383, 0, 0],
        "8934": [0.23222, 0.74111, 0, 0],
        "8935": [0.23222, 0.74111, 0, 0],
        "8936": [0.23222, 0.74111, 0, 0],
        "8937": [0.23222, 0.74111, 0, 0],
        "8938": [0.20576, 0.70576, 0, 0],
        "8939": [0.20576, 0.70576, 0, 0],
        "8940": [0.30274, 0.79383, 0, 0],
        "8941": [0.30274, 0.79383, 0, 0],
        "8994": [0.19444, 0.69224, 0, 0],
        "8995": [0.19444, 0.69224, 0, 0],
        "9416": [0.15559, 0.69224, 0, 0],
        "9484": [0, 0.69224, 0, 0],
        "9488": [0, 0.69224, 0, 0],
        "9492": [0, 0.37788, 0, 0],
        "9496": [0, 0.37788, 0, 0],
        "9585": [0.19444, 0.68889, 0, 0],
        "9586": [0.19444, 0.74111, 0, 0],
        "9632": [0, 0.675, 0, 0],
        "9633": [0, 0.675, 0, 0],
        "9650": [0, 0.54986, 0, 0],
        "9651": [0, 0.54986, 0, 0],
        "9654": [0.03517, 0.54986, 0, 0],
        "9660": [0, 0.54986, 0, 0],
        "9661": [0, 0.54986, 0, 0],
        "9664": [0.03517, 0.54986, 0, 0],
        "9674": [0.11111, 0.69224, 0, 0],
        "9733": [0.19444, 0.69224, 0, 0],
        "10003": [0, 0.69224, 0, 0],
        "10016": [0, 0.69224, 0, 0],
        "10731": [0.11111, 0.69224, 0, 0],
        "10846": [0.19444, 0.75583, 0, 0],
        "10877": [0.13667, 0.63667, 0, 0],
        "10878": [0.13667, 0.63667, 0, 0],
        "10885": [0.25583, 0.75583, 0, 0],
        "10886": [0.25583, 0.75583, 0, 0],
        "10887": [0.13597, 0.63597, 0, 0],
        "10888": [0.13597, 0.63597, 0, 0],
        "10889": [0.26167, 0.75726, 0, 0],
        "10890": [0.26167, 0.75726, 0, 0],
        "10891": [0.48256, 0.98256, 0, 0],
        "10892": [0.48256, 0.98256, 0, 0],
        "10901": [0.13667, 0.63667, 0, 0],
        "10902": [0.13667, 0.63667, 0, 0],
        "10933": [0.25142, 0.75726, 0, 0],
        "10934": [0.25142, 0.75726, 0, 0],
        "10935": [0.26167, 0.75726, 0, 0],
        "10936": [0.26167, 0.75726, 0, 0],
        "10937": [0.26167, 0.75726, 0, 0],
        "10938": [0.26167, 0.75726, 0, 0],
        "10949": [0.25583, 0.75583, 0, 0],
        "10950": [0.25583, 0.75583, 0, 0],
        "10955": [0.28481, 0.79383, 0, 0],
        "10956": [0.28481, 0.79383, 0, 0],
        "57350": [0.08167, 0.58167, 0, 0],
        "57351": [0.08167, 0.58167, 0, 0],
        "57352": [0.08167, 0.58167, 0, 0],
        "57353": [0, 0.43056, 0.04028, 0],
        "57356": [0.25142, 0.75726, 0, 0],
        "57357": [0.25142, 0.75726, 0, 0],
        "57358": [0.41951, 0.91951, 0, 0],
        "57359": [0.30274, 0.79383, 0, 0],
        "57360": [0.30274, 0.79383, 0, 0],
        "57361": [0.41951, 0.91951, 0, 0],
        "57366": [0.25142, 0.75726, 0, 0],
        "57367": [0.25142, 0.75726, 0, 0],
        "57368": [0.25142, 0.75726, 0, 0],
        "57369": [0.25142, 0.75726, 0, 0],
        "57370": [0.13597, 0.63597, 0, 0],
        "57371": [0.13597, 0.63597, 0, 0]
      },
      "Caligraphic-Regular": {
        "48": [0, 0.43056, 0, 0],
        "49": [0, 0.43056, 0, 0],
        "50": [0, 0.43056, 0, 0],
        "51": [0.19444, 0.43056, 0, 0],
        "52": [0.19444, 0.43056, 0, 0],
        "53": [0.19444, 0.43056, 0, 0],
        "54": [0, 0.64444, 0, 0],
        "55": [0.19444, 0.43056, 0, 0],
        "56": [0, 0.64444, 0, 0],
        "57": [0.19444, 0.43056, 0, 0],
        "65": [0, 0.68333, 0, 0.19445],
        "66": [0, 0.68333, 0.03041, 0.13889],
        "67": [0, 0.68333, 0.05834, 0.13889],
        "68": [0, 0.68333, 0.02778, 0.08334],
        "69": [0, 0.68333, 0.08944, 0.11111],
        "70": [0, 0.68333, 0.09931, 0.11111],
        "71": [0.09722, 0.68333, 0.0593, 0.11111],
        "72": [0, 0.68333, 965e-5, 0.11111],
        "73": [0, 0.68333, 0.07382, 0],
        "74": [0.09722, 0.68333, 0.18472, 0.16667],
        "75": [0, 0.68333, 0.01445, 0.05556],
        "76": [0, 0.68333, 0, 0.13889],
        "77": [0, 0.68333, 0, 0.13889],
        "78": [0, 0.68333, 0.14736, 0.08334],
        "79": [0, 0.68333, 0.02778, 0.11111],
        "80": [0, 0.68333, 0.08222, 0.08334],
        "81": [0.09722, 0.68333, 0, 0.11111],
        "82": [0, 0.68333, 0, 0.08334],
        "83": [0, 0.68333, 0.075, 0.13889],
        "84": [0, 0.68333, 0.25417, 0],
        "85": [0, 0.68333, 0.09931, 0.08334],
        "86": [0, 0.68333, 0.08222, 0],
        "87": [0, 0.68333, 0.08222, 0.08334],
        "88": [0, 0.68333, 0.14643, 0.13889],
        "89": [0.09722, 0.68333, 0.08222, 0.08334],
        "90": [0, 0.68333, 0.07944, 0.13889]
      },
      "Fraktur-Regular": {
        "33": [0, 0.69141, 0, 0],
        "34": [0, 0.69141, 0, 0],
        "38": [0, 0.69141, 0, 0],
        "39": [0, 0.69141, 0, 0],
        "40": [0.24982, 0.74947, 0, 0],
        "41": [0.24982, 0.74947, 0, 0],
        "42": [0, 0.62119, 0, 0],
        "43": [0.08319, 0.58283, 0, 0],
        "44": [0, 0.10803, 0, 0],
        "45": [0.08319, 0.58283, 0, 0],
        "46": [0, 0.10803, 0, 0],
        "47": [0.24982, 0.74947, 0, 0],
        "48": [0, 0.47534, 0, 0],
        "49": [0, 0.47534, 0, 0],
        "50": [0, 0.47534, 0, 0],
        "51": [0.18906, 0.47534, 0, 0],
        "52": [0.18906, 0.47534, 0, 0],
        "53": [0.18906, 0.47534, 0, 0],
        "54": [0, 0.69141, 0, 0],
        "55": [0.18906, 0.47534, 0, 0],
        "56": [0, 0.69141, 0, 0],
        "57": [0.18906, 0.47534, 0, 0],
        "58": [0, 0.47534, 0, 0],
        "59": [0.12604, 0.47534, 0, 0],
        "61": [-0.13099, 0.36866, 0, 0],
        "63": [0, 0.69141, 0, 0],
        "65": [0, 0.69141, 0, 0],
        "66": [0, 0.69141, 0, 0],
        "67": [0, 0.69141, 0, 0],
        "68": [0, 0.69141, 0, 0],
        "69": [0, 0.69141, 0, 0],
        "70": [0.12604, 0.69141, 0, 0],
        "71": [0, 0.69141, 0, 0],
        "72": [0.06302, 0.69141, 0, 0],
        "73": [0, 0.69141, 0, 0],
        "74": [0.12604, 0.69141, 0, 0],
        "75": [0, 0.69141, 0, 0],
        "76": [0, 0.69141, 0, 0],
        "77": [0, 0.69141, 0, 0],
        "78": [0, 0.69141, 0, 0],
        "79": [0, 0.69141, 0, 0],
        "80": [0.18906, 0.69141, 0, 0],
        "81": [0.03781, 0.69141, 0, 0],
        "82": [0, 0.69141, 0, 0],
        "83": [0, 0.69141, 0, 0],
        "84": [0, 0.69141, 0, 0],
        "85": [0, 0.69141, 0, 0],
        "86": [0, 0.69141, 0, 0],
        "87": [0, 0.69141, 0, 0],
        "88": [0, 0.69141, 0, 0],
        "89": [0.18906, 0.69141, 0, 0],
        "90": [0.12604, 0.69141, 0, 0],
        "91": [0.24982, 0.74947, 0, 0],
        "93": [0.24982, 0.74947, 0, 0],
        "94": [0, 0.69141, 0, 0],
        "97": [0, 0.47534, 0, 0],
        "98": [0, 0.69141, 0, 0],
        "99": [0, 0.47534, 0, 0],
        "100": [0, 0.62119, 0, 0],
        "101": [0, 0.47534, 0, 0],
        "102": [0.18906, 0.69141, 0, 0],
        "103": [0.18906, 0.47534, 0, 0],
        "104": [0.18906, 0.69141, 0, 0],
        "105": [0, 0.69141, 0, 0],
        "106": [0, 0.69141, 0, 0],
        "107": [0, 0.69141, 0, 0],
        "108": [0, 0.69141, 0, 0],
        "109": [0, 0.47534, 0, 0],
        "110": [0, 0.47534, 0, 0],
        "111": [0, 0.47534, 0, 0],
        "112": [0.18906, 0.52396, 0, 0],
        "113": [0.18906, 0.47534, 0, 0],
        "114": [0, 0.47534, 0, 0],
        "115": [0, 0.47534, 0, 0],
        "116": [0, 0.62119, 0, 0],
        "117": [0, 0.47534, 0, 0],
        "118": [0, 0.52396, 0, 0],
        "119": [0, 0.52396, 0, 0],
        "120": [0.18906, 0.47534, 0, 0],
        "121": [0.18906, 0.47534, 0, 0],
        "122": [0.18906, 0.47534, 0, 0],
        "8216": [0, 0.69141, 0, 0],
        "8217": [0, 0.69141, 0, 0],
        "58112": [0, 0.62119, 0, 0],
        "58113": [0, 0.62119, 0, 0],
        "58114": [0.18906, 0.69141, 0, 0],
        "58115": [0.18906, 0.69141, 0, 0],
        "58116": [0.18906, 0.47534, 0, 0],
        "58117": [0, 0.69141, 0, 0],
        "58118": [0, 0.62119, 0, 0],
        "58119": [0, 0.47534, 0, 0]
      },
      "Main-Bold": {
        "33": [0, 0.69444, 0, 0],
        "34": [0, 0.69444, 0, 0],
        "35": [0.19444, 0.69444, 0, 0],
        "36": [0.05556, 0.75, 0, 0],
        "37": [0.05556, 0.75, 0, 0],
        "38": [0, 0.69444, 0, 0],
        "39": [0, 0.69444, 0, 0],
        "40": [0.25, 0.75, 0, 0],
        "41": [0.25, 0.75, 0, 0],
        "42": [0, 0.75, 0, 0],
        "43": [0.13333, 0.63333, 0, 0],
        "44": [0.19444, 0.15556, 0, 0],
        "45": [0, 0.44444, 0, 0],
        "46": [0, 0.15556, 0, 0],
        "47": [0.25, 0.75, 0, 0],
        "48": [0, 0.64444, 0, 0],
        "49": [0, 0.64444, 0, 0],
        "50": [0, 0.64444, 0, 0],
        "51": [0, 0.64444, 0, 0],
        "52": [0, 0.64444, 0, 0],
        "53": [0, 0.64444, 0, 0],
        "54": [0, 0.64444, 0, 0],
        "55": [0, 0.64444, 0, 0],
        "56": [0, 0.64444, 0, 0],
        "57": [0, 0.64444, 0, 0],
        "58": [0, 0.44444, 0, 0],
        "59": [0.19444, 0.44444, 0, 0],
        "60": [0.08556, 0.58556, 0, 0],
        "61": [-0.10889, 0.39111, 0, 0],
        "62": [0.08556, 0.58556, 0, 0],
        "63": [0, 0.69444, 0, 0],
        "64": [0, 0.69444, 0, 0],
        "65": [0, 0.68611, 0, 0],
        "66": [0, 0.68611, 0, 0],
        "67": [0, 0.68611, 0, 0],
        "68": [0, 0.68611, 0, 0],
        "69": [0, 0.68611, 0, 0],
        "70": [0, 0.68611, 0, 0],
        "71": [0, 0.68611, 0, 0],
        "72": [0, 0.68611, 0, 0],
        "73": [0, 0.68611, 0, 0],
        "74": [0, 0.68611, 0, 0],
        "75": [0, 0.68611, 0, 0],
        "76": [0, 0.68611, 0, 0],
        "77": [0, 0.68611, 0, 0],
        "78": [0, 0.68611, 0, 0],
        "79": [0, 0.68611, 0, 0],
        "80": [0, 0.68611, 0, 0],
        "81": [0.19444, 0.68611, 0, 0],
        "82": [0, 0.68611, 0, 0],
        "83": [0, 0.68611, 0, 0],
        "84": [0, 0.68611, 0, 0],
        "85": [0, 0.68611, 0, 0],
        "86": [0, 0.68611, 0.01597, 0],
        "87": [0, 0.68611, 0.01597, 0],
        "88": [0, 0.68611, 0, 0],
        "89": [0, 0.68611, 0.02875, 0],
        "90": [0, 0.68611, 0, 0],
        "91": [0.25, 0.75, 0, 0],
        "92": [0.25, 0.75, 0, 0],
        "93": [0.25, 0.75, 0, 0],
        "94": [0, 0.69444, 0, 0],
        "95": [0.31, 0.13444, 0.03194, 0],
        "96": [0, 0.69444, 0, 0],
        "97": [0, 0.44444, 0, 0],
        "98": [0, 0.69444, 0, 0],
        "99": [0, 0.44444, 0, 0],
        "100": [0, 0.69444, 0, 0],
        "101": [0, 0.44444, 0, 0],
        "102": [0, 0.69444, 0.10903, 0],
        "103": [0.19444, 0.44444, 0.01597, 0],
        "104": [0, 0.69444, 0, 0],
        "105": [0, 0.69444, 0, 0],
        "106": [0.19444, 0.69444, 0, 0],
        "107": [0, 0.69444, 0, 0],
        "108": [0, 0.69444, 0, 0],
        "109": [0, 0.44444, 0, 0],
        "110": [0, 0.44444, 0, 0],
        "111": [0, 0.44444, 0, 0],
        "112": [0.19444, 0.44444, 0, 0],
        "113": [0.19444, 0.44444, 0, 0],
        "114": [0, 0.44444, 0, 0],
        "115": [0, 0.44444, 0, 0],
        "116": [0, 0.63492, 0, 0],
        "117": [0, 0.44444, 0, 0],
        "118": [0, 0.44444, 0.01597, 0],
        "119": [0, 0.44444, 0.01597, 0],
        "120": [0, 0.44444, 0, 0],
        "121": [0.19444, 0.44444, 0.01597, 0],
        "122": [0, 0.44444, 0, 0],
        "123": [0.25, 0.75, 0, 0],
        "124": [0.25, 0.75, 0, 0],
        "125": [0.25, 0.75, 0, 0],
        "126": [0.35, 0.34444, 0, 0],
        "168": [0, 0.69444, 0, 0],
        "172": [0, 0.44444, 0, 0],
        "175": [0, 0.59611, 0, 0],
        "176": [0, 0.69444, 0, 0],
        "177": [0.13333, 0.63333, 0, 0],
        "180": [0, 0.69444, 0, 0],
        "215": [0.13333, 0.63333, 0, 0],
        "247": [0.13333, 0.63333, 0, 0],
        "305": [0, 0.44444, 0, 0],
        "567": [0.19444, 0.44444, 0, 0],
        "710": [0, 0.69444, 0, 0],
        "711": [0, 0.63194, 0, 0],
        "713": [0, 0.59611, 0, 0],
        "714": [0, 0.69444, 0, 0],
        "715": [0, 0.69444, 0, 0],
        "728": [0, 0.69444, 0, 0],
        "729": [0, 0.69444, 0, 0],
        "730": [0, 0.69444, 0, 0],
        "732": [0, 0.69444, 0, 0],
        "768": [0, 0.69444, 0, 0],
        "769": [0, 0.69444, 0, 0],
        "770": [0, 0.69444, 0, 0],
        "771": [0, 0.69444, 0, 0],
        "772": [0, 0.59611, 0, 0],
        "774": [0, 0.69444, 0, 0],
        "775": [0, 0.69444, 0, 0],
        "776": [0, 0.69444, 0, 0],
        "778": [0, 0.69444, 0, 0],
        "779": [0, 0.69444, 0, 0],
        "780": [0, 0.63194, 0, 0],
        "824": [0.19444, 0.69444, 0, 0],
        "915": [0, 0.68611, 0, 0],
        "916": [0, 0.68611, 0, 0],
        "920": [0, 0.68611, 0, 0],
        "923": [0, 0.68611, 0, 0],
        "926": [0, 0.68611, 0, 0],
        "928": [0, 0.68611, 0, 0],
        "931": [0, 0.68611, 0, 0],
        "933": [0, 0.68611, 0, 0],
        "934": [0, 0.68611, 0, 0],
        "936": [0, 0.68611, 0, 0],
        "937": [0, 0.68611, 0, 0],
        "8211": [0, 0.44444, 0.03194, 0],
        "8212": [0, 0.44444, 0.03194, 0],
        "8216": [0, 0.69444, 0, 0],
        "8217": [0, 0.69444, 0, 0],
        "8220": [0, 0.69444, 0, 0],
        "8221": [0, 0.69444, 0, 0],
        "8224": [0.19444, 0.69444, 0, 0],
        "8225": [0.19444, 0.69444, 0, 0],
        "8242": [0, 0.55556, 0, 0],
        "8407": [0, 0.72444, 0.15486, 0],
        "8463": [0, 0.69444, 0, 0],
        "8465": [0, 0.69444, 0, 0],
        "8467": [0, 0.69444, 0, 0],
        "8472": [0.19444, 0.44444, 0, 0],
        "8476": [0, 0.69444, 0, 0],
        "8501": [0, 0.69444, 0, 0],
        "8592": [-0.10889, 0.39111, 0, 0],
        "8593": [0.19444, 0.69444, 0, 0],
        "8594": [-0.10889, 0.39111, 0, 0],
        "8595": [0.19444, 0.69444, 0, 0],
        "8596": [-0.10889, 0.39111, 0, 0],
        "8597": [0.25, 0.75, 0, 0],
        "8598": [0.19444, 0.69444, 0, 0],
        "8599": [0.19444, 0.69444, 0, 0],
        "8600": [0.19444, 0.69444, 0, 0],
        "8601": [0.19444, 0.69444, 0, 0],
        "8636": [-0.10889, 0.39111, 0, 0],
        "8637": [-0.10889, 0.39111, 0, 0],
        "8640": [-0.10889, 0.39111, 0, 0],
        "8641": [-0.10889, 0.39111, 0, 0],
        "8656": [-0.10889, 0.39111, 0, 0],
        "8657": [0.19444, 0.69444, 0, 0],
        "8658": [-0.10889, 0.39111, 0, 0],
        "8659": [0.19444, 0.69444, 0, 0],
        "8660": [-0.10889, 0.39111, 0, 0],
        "8661": [0.25, 0.75, 0, 0],
        "8704": [0, 0.69444, 0, 0],
        "8706": [0, 0.69444, 0.06389, 0],
        "8707": [0, 0.69444, 0, 0],
        "8709": [0.05556, 0.75, 0, 0],
        "8711": [0, 0.68611, 0, 0],
        "8712": [0.08556, 0.58556, 0, 0],
        "8715": [0.08556, 0.58556, 0, 0],
        "8722": [0.13333, 0.63333, 0, 0],
        "8723": [0.13333, 0.63333, 0, 0],
        "8725": [0.25, 0.75, 0, 0],
        "8726": [0.25, 0.75, 0, 0],
        "8727": [-0.02778, 0.47222, 0, 0],
        "8728": [-0.02639, 0.47361, 0, 0],
        "8729": [-0.02639, 0.47361, 0, 0],
        "8730": [0.18, 0.82, 0, 0],
        "8733": [0, 0.44444, 0, 0],
        "8734": [0, 0.44444, 0, 0],
        "8736": [0, 0.69224, 0, 0],
        "8739": [0.25, 0.75, 0, 0],
        "8741": [0.25, 0.75, 0, 0],
        "8743": [0, 0.55556, 0, 0],
        "8744": [0, 0.55556, 0, 0],
        "8745": [0, 0.55556, 0, 0],
        "8746": [0, 0.55556, 0, 0],
        "8747": [0.19444, 0.69444, 0.12778, 0],
        "8764": [-0.10889, 0.39111, 0, 0],
        "8768": [0.19444, 0.69444, 0, 0],
        "8771": [222e-5, 0.50222, 0, 0],
        "8776": [0.02444, 0.52444, 0, 0],
        "8781": [222e-5, 0.50222, 0, 0],
        "8801": [222e-5, 0.50222, 0, 0],
        "8804": [0.19667, 0.69667, 0, 0],
        "8805": [0.19667, 0.69667, 0, 0],
        "8810": [0.08556, 0.58556, 0, 0],
        "8811": [0.08556, 0.58556, 0, 0],
        "8826": [0.08556, 0.58556, 0, 0],
        "8827": [0.08556, 0.58556, 0, 0],
        "8834": [0.08556, 0.58556, 0, 0],
        "8835": [0.08556, 0.58556, 0, 0],
        "8838": [0.19667, 0.69667, 0, 0],
        "8839": [0.19667, 0.69667, 0, 0],
        "8846": [0, 0.55556, 0, 0],
        "8849": [0.19667, 0.69667, 0, 0],
        "8850": [0.19667, 0.69667, 0, 0],
        "8851": [0, 0.55556, 0, 0],
        "8852": [0, 0.55556, 0, 0],
        "8853": [0.13333, 0.63333, 0, 0],
        "8854": [0.13333, 0.63333, 0, 0],
        "8855": [0.13333, 0.63333, 0, 0],
        "8856": [0.13333, 0.63333, 0, 0],
        "8857": [0.13333, 0.63333, 0, 0],
        "8866": [0, 0.69444, 0, 0],
        "8867": [0, 0.69444, 0, 0],
        "8868": [0, 0.69444, 0, 0],
        "8869": [0, 0.69444, 0, 0],
        "8900": [-0.02639, 0.47361, 0, 0],
        "8901": [-0.02639, 0.47361, 0, 0],
        "8902": [-0.02778, 0.47222, 0, 0],
        "8968": [0.25, 0.75, 0, 0],
        "8969": [0.25, 0.75, 0, 0],
        "8970": [0.25, 0.75, 0, 0],
        "8971": [0.25, 0.75, 0, 0],
        "8994": [-0.13889, 0.36111, 0, 0],
        "8995": [-0.13889, 0.36111, 0, 0],
        "9651": [0.19444, 0.69444, 0, 0],
        "9657": [-0.02778, 0.47222, 0, 0],
        "9661": [0.19444, 0.69444, 0, 0],
        "9667": [-0.02778, 0.47222, 0, 0],
        "9711": [0.19444, 0.69444, 0, 0],
        "9824": [0.12963, 0.69444, 0, 0],
        "9825": [0.12963, 0.69444, 0, 0],
        "9826": [0.12963, 0.69444, 0, 0],
        "9827": [0.12963, 0.69444, 0, 0],
        "9837": [0, 0.75, 0, 0],
        "9838": [0.19444, 0.69444, 0, 0],
        "9839": [0.19444, 0.69444, 0, 0],
        "10216": [0.25, 0.75, 0, 0],
        "10217": [0.25, 0.75, 0, 0],
        "10815": [0, 0.68611, 0, 0],
        "10927": [0.19667, 0.69667, 0, 0],
        "10928": [0.19667, 0.69667, 0, 0]
      },
      "Main-Italic": {
        "33": [0, 0.69444, 0.12417, 0],
        "34": [0, 0.69444, 0.06961, 0],
        "35": [0.19444, 0.69444, 0.06616, 0],
        "37": [0.05556, 0.75, 0.13639, 0],
        "38": [0, 0.69444, 0.09694, 0],
        "39": [0, 0.69444, 0.12417, 0],
        "40": [0.25, 0.75, 0.16194, 0],
        "41": [0.25, 0.75, 0.03694, 0],
        "42": [0, 0.75, 0.14917, 0],
        "43": [0.05667, 0.56167, 0.03694, 0],
        "44": [0.19444, 0.10556, 0, 0],
        "45": [0, 0.43056, 0.02826, 0],
        "46": [0, 0.10556, 0, 0],
        "47": [0.25, 0.75, 0.16194, 0],
        "48": [0, 0.64444, 0.13556, 0],
        "49": [0, 0.64444, 0.13556, 0],
        "50": [0, 0.64444, 0.13556, 0],
        "51": [0, 0.64444, 0.13556, 0],
        "52": [0.19444, 0.64444, 0.13556, 0],
        "53": [0, 0.64444, 0.13556, 0],
        "54": [0, 0.64444, 0.13556, 0],
        "55": [0.19444, 0.64444, 0.13556, 0],
        "56": [0, 0.64444, 0.13556, 0],
        "57": [0, 0.64444, 0.13556, 0],
        "58": [0, 0.43056, 0.0582, 0],
        "59": [0.19444, 0.43056, 0.0582, 0],
        "61": [-0.13313, 0.36687, 0.06616, 0],
        "63": [0, 0.69444, 0.1225, 0],
        "64": [0, 0.69444, 0.09597, 0],
        "65": [0, 0.68333, 0, 0],
        "66": [0, 0.68333, 0.10257, 0],
        "67": [0, 0.68333, 0.14528, 0],
        "68": [0, 0.68333, 0.09403, 0],
        "69": [0, 0.68333, 0.12028, 0],
        "70": [0, 0.68333, 0.13305, 0],
        "71": [0, 0.68333, 0.08722, 0],
        "72": [0, 0.68333, 0.16389, 0],
        "73": [0, 0.68333, 0.15806, 0],
        "74": [0, 0.68333, 0.14028, 0],
        "75": [0, 0.68333, 0.14528, 0],
        "76": [0, 0.68333, 0, 0],
        "77": [0, 0.68333, 0.16389, 0],
        "78": [0, 0.68333, 0.16389, 0],
        "79": [0, 0.68333, 0.09403, 0],
        "80": [0, 0.68333, 0.10257, 0],
        "81": [0.19444, 0.68333, 0.09403, 0],
        "82": [0, 0.68333, 0.03868, 0],
        "83": [0, 0.68333, 0.11972, 0],
        "84": [0, 0.68333, 0.13305, 0],
        "85": [0, 0.68333, 0.16389, 0],
        "86": [0, 0.68333, 0.18361, 0],
        "87": [0, 0.68333, 0.18361, 0],
        "88": [0, 0.68333, 0.15806, 0],
        "89": [0, 0.68333, 0.19383, 0],
        "90": [0, 0.68333, 0.14528, 0],
        "91": [0.25, 0.75, 0.1875, 0],
        "93": [0.25, 0.75, 0.10528, 0],
        "94": [0, 0.69444, 0.06646, 0],
        "95": [0.31, 0.12056, 0.09208, 0],
        "97": [0, 0.43056, 0.07671, 0],
        "98": [0, 0.69444, 0.06312, 0],
        "99": [0, 0.43056, 0.05653, 0],
        "100": [0, 0.69444, 0.10333, 0],
        "101": [0, 0.43056, 0.07514, 0],
        "102": [0.19444, 0.69444, 0.21194, 0],
        "103": [0.19444, 0.43056, 0.08847, 0],
        "104": [0, 0.69444, 0.07671, 0],
        "105": [0, 0.65536, 0.1019, 0],
        "106": [0.19444, 0.65536, 0.14467, 0],
        "107": [0, 0.69444, 0.10764, 0],
        "108": [0, 0.69444, 0.10333, 0],
        "109": [0, 0.43056, 0.07671, 0],
        "110": [0, 0.43056, 0.07671, 0],
        "111": [0, 0.43056, 0.06312, 0],
        "112": [0.19444, 0.43056, 0.06312, 0],
        "113": [0.19444, 0.43056, 0.08847, 0],
        "114": [0, 0.43056, 0.10764, 0],
        "115": [0, 0.43056, 0.08208, 0],
        "116": [0, 0.61508, 0.09486, 0],
        "117": [0, 0.43056, 0.07671, 0],
        "118": [0, 0.43056, 0.10764, 0],
        "119": [0, 0.43056, 0.10764, 0],
        "120": [0, 0.43056, 0.12042, 0],
        "121": [0.19444, 0.43056, 0.08847, 0],
        "122": [0, 0.43056, 0.12292, 0],
        "126": [0.35, 0.31786, 0.11585, 0],
        "163": [0, 0.69444, 0, 0],
        "305": [0, 0.43056, 0, 0.02778],
        "567": [0.19444, 0.43056, 0, 0.08334],
        "768": [0, 0.69444, 0, 0],
        "769": [0, 0.69444, 0.09694, 0],
        "770": [0, 0.69444, 0.06646, 0],
        "771": [0, 0.66786, 0.11585, 0],
        "772": [0, 0.56167, 0.10333, 0],
        "774": [0, 0.69444, 0.10806, 0],
        "775": [0, 0.66786, 0.11752, 0],
        "776": [0, 0.66786, 0.10474, 0],
        "778": [0, 0.69444, 0, 0],
        "779": [0, 0.69444, 0.1225, 0],
        "780": [0, 0.62847, 0.08295, 0],
        "915": [0, 0.68333, 0.13305, 0],
        "916": [0, 0.68333, 0, 0],
        "920": [0, 0.68333, 0.09403, 0],
        "923": [0, 0.68333, 0, 0],
        "926": [0, 0.68333, 0.15294, 0],
        "928": [0, 0.68333, 0.16389, 0],
        "931": [0, 0.68333, 0.12028, 0],
        "933": [0, 0.68333, 0.11111, 0],
        "934": [0, 0.68333, 0.05986, 0],
        "936": [0, 0.68333, 0.11111, 0],
        "937": [0, 0.68333, 0.10257, 0],
        "8211": [0, 0.43056, 0.09208, 0],
        "8212": [0, 0.43056, 0.09208, 0],
        "8216": [0, 0.69444, 0.12417, 0],
        "8217": [0, 0.69444, 0.12417, 0],
        "8220": [0, 0.69444, 0.1685, 0],
        "8221": [0, 0.69444, 0.06961, 0],
        "8463": [0, 0.68889, 0, 0]
      },
      "Main-Regular": {
        "32": [0, 0, 0, 0],
        "33": [0, 0.69444, 0, 0],
        "34": [0, 0.69444, 0, 0],
        "35": [0.19444, 0.69444, 0, 0],
        "36": [0.05556, 0.75, 0, 0],
        "37": [0.05556, 0.75, 0, 0],
        "38": [0, 0.69444, 0, 0],
        "39": [0, 0.69444, 0, 0],
        "40": [0.25, 0.75, 0, 0],
        "41": [0.25, 0.75, 0, 0],
        "42": [0, 0.75, 0, 0],
        "43": [0.08333, 0.58333, 0, 0],
        "44": [0.19444, 0.10556, 0, 0],
        "45": [0, 0.43056, 0, 0],
        "46": [0, 0.10556, 0, 0],
        "47": [0.25, 0.75, 0, 0],
        "48": [0, 0.64444, 0, 0],
        "49": [0, 0.64444, 0, 0],
        "50": [0, 0.64444, 0, 0],
        "51": [0, 0.64444, 0, 0],
        "52": [0, 0.64444, 0, 0],
        "53": [0, 0.64444, 0, 0],
        "54": [0, 0.64444, 0, 0],
        "55": [0, 0.64444, 0, 0],
        "56": [0, 0.64444, 0, 0],
        "57": [0, 0.64444, 0, 0],
        "58": [0, 0.43056, 0, 0],
        "59": [0.19444, 0.43056, 0, 0],
        "60": [0.0391, 0.5391, 0, 0],
        "61": [-0.13313, 0.36687, 0, 0],
        "62": [0.0391, 0.5391, 0, 0],
        "63": [0, 0.69444, 0, 0],
        "64": [0, 0.69444, 0, 0],
        "65": [0, 0.68333, 0, 0],
        "66": [0, 0.68333, 0, 0],
        "67": [0, 0.68333, 0, 0],
        "68": [0, 0.68333, 0, 0],
        "69": [0, 0.68333, 0, 0],
        "70": [0, 0.68333, 0, 0],
        "71": [0, 0.68333, 0, 0],
        "72": [0, 0.68333, 0, 0],
        "73": [0, 0.68333, 0, 0],
        "74": [0, 0.68333, 0, 0],
        "75": [0, 0.68333, 0, 0],
        "76": [0, 0.68333, 0, 0],
        "77": [0, 0.68333, 0, 0],
        "78": [0, 0.68333, 0, 0],
        "79": [0, 0.68333, 0, 0],
        "80": [0, 0.68333, 0, 0],
        "81": [0.19444, 0.68333, 0, 0],
        "82": [0, 0.68333, 0, 0],
        "83": [0, 0.68333, 0, 0],
        "84": [0, 0.68333, 0, 0],
        "85": [0, 0.68333, 0, 0],
        "86": [0, 0.68333, 0.01389, 0],
        "87": [0, 0.68333, 0.01389, 0],
        "88": [0, 0.68333, 0, 0],
        "89": [0, 0.68333, 0.025, 0],
        "90": [0, 0.68333, 0, 0],
        "91": [0.25, 0.75, 0, 0],
        "92": [0.25, 0.75, 0, 0],
        "93": [0.25, 0.75, 0, 0],
        "94": [0, 0.69444, 0, 0],
        "95": [0.31, 0.12056, 0.02778, 0],
        "96": [0, 0.69444, 0, 0],
        "97": [0, 0.43056, 0, 0],
        "98": [0, 0.69444, 0, 0],
        "99": [0, 0.43056, 0, 0],
        "100": [0, 0.69444, 0, 0],
        "101": [0, 0.43056, 0, 0],
        "102": [0, 0.69444, 0.07778, 0],
        "103": [0.19444, 0.43056, 0.01389, 0],
        "104": [0, 0.69444, 0, 0],
        "105": [0, 0.66786, 0, 0],
        "106": [0.19444, 0.66786, 0, 0],
        "107": [0, 0.69444, 0, 0],
        "108": [0, 0.69444, 0, 0],
        "109": [0, 0.43056, 0, 0],
        "110": [0, 0.43056, 0, 0],
        "111": [0, 0.43056, 0, 0],
        "112": [0.19444, 0.43056, 0, 0],
        "113": [0.19444, 0.43056, 0, 0],
        "114": [0, 0.43056, 0, 0],
        "115": [0, 0.43056, 0, 0],
        "116": [0, 0.61508, 0, 0],
        "117": [0, 0.43056, 0, 0],
        "118": [0, 0.43056, 0.01389, 0],
        "119": [0, 0.43056, 0.01389, 0],
        "120": [0, 0.43056, 0, 0],
        "121": [0.19444, 0.43056, 0.01389, 0],
        "122": [0, 0.43056, 0, 0],
        "123": [0.25, 0.75, 0, 0],
        "124": [0.25, 0.75, 0, 0],
        "125": [0.25, 0.75, 0, 0],
        "126": [0.35, 0.31786, 0, 0],
        "160": [0, 0, 0, 0],
        "168": [0, 0.66786, 0, 0],
        "172": [0, 0.43056, 0, 0],
        "175": [0, 0.56778, 0, 0],
        "176": [0, 0.69444, 0, 0],
        "177": [0.08333, 0.58333, 0, 0],
        "180": [0, 0.69444, 0, 0],
        "215": [0.08333, 0.58333, 0, 0],
        "247": [0.08333, 0.58333, 0, 0],
        "305": [0, 0.43056, 0, 0],
        "567": [0.19444, 0.43056, 0, 0],
        "710": [0, 0.69444, 0, 0],
        "711": [0, 0.62847, 0, 0],
        "713": [0, 0.56778, 0, 0],
        "714": [0, 0.69444, 0, 0],
        "715": [0, 0.69444, 0, 0],
        "728": [0, 0.69444, 0, 0],
        "729": [0, 0.66786, 0, 0],
        "730": [0, 0.69444, 0, 0],
        "732": [0, 0.66786, 0, 0],
        "768": [0, 0.69444, 0, 0],
        "769": [0, 0.69444, 0, 0],
        "770": [0, 0.69444, 0, 0],
        "771": [0, 0.66786, 0, 0],
        "772": [0, 0.56778, 0, 0],
        "774": [0, 0.69444, 0, 0],
        "775": [0, 0.66786, 0, 0],
        "776": [0, 0.66786, 0, 0],
        "778": [0, 0.69444, 0, 0],
        "779": [0, 0.69444, 0, 0],
        "780": [0, 0.62847, 0, 0],
        "824": [0.19444, 0.69444, 0, 0],
        "915": [0, 0.68333, 0, 0],
        "916": [0, 0.68333, 0, 0],
        "920": [0, 0.68333, 0, 0],
        "923": [0, 0.68333, 0, 0],
        "926": [0, 0.68333, 0, 0],
        "928": [0, 0.68333, 0, 0],
        "931": [0, 0.68333, 0, 0],
        "933": [0, 0.68333, 0, 0],
        "934": [0, 0.68333, 0, 0],
        "936": [0, 0.68333, 0, 0],
        "937": [0, 0.68333, 0, 0],
        "8211": [0, 0.43056, 0.02778, 0],
        "8212": [0, 0.43056, 0.02778, 0],
        "8216": [0, 0.69444, 0, 0],
        "8217": [0, 0.69444, 0, 0],
        "8220": [0, 0.69444, 0, 0],
        "8221": [0, 0.69444, 0, 0],
        "8224": [0.19444, 0.69444, 0, 0],
        "8225": [0.19444, 0.69444, 0, 0],
        "8230": [0, 0.12, 0, 0],
        "8242": [0, 0.55556, 0, 0],
        "8407": [0, 0.71444, 0.15382, 0],
        "8463": [0, 0.68889, 0, 0],
        "8465": [0, 0.69444, 0, 0],
        "8467": [0, 0.69444, 0, 0.11111],
        "8472": [0.19444, 0.43056, 0, 0.11111],
        "8476": [0, 0.69444, 0, 0],
        "8501": [0, 0.69444, 0, 0],
        "8592": [-0.13313, 0.36687, 0, 0],
        "8593": [0.19444, 0.69444, 0, 0],
        "8594": [-0.13313, 0.36687, 0, 0],
        "8595": [0.19444, 0.69444, 0, 0],
        "8596": [-0.13313, 0.36687, 0, 0],
        "8597": [0.25, 0.75, 0, 0],
        "8598": [0.19444, 0.69444, 0, 0],
        "8599": [0.19444, 0.69444, 0, 0],
        "8600": [0.19444, 0.69444, 0, 0],
        "8601": [0.19444, 0.69444, 0, 0],
        "8614": [0.011, 0.511, 0, 0],
        "8617": [0.011, 0.511, 0, 0],
        "8618": [0.011, 0.511, 0, 0],
        "8636": [-0.13313, 0.36687, 0, 0],
        "8637": [-0.13313, 0.36687, 0, 0],
        "8640": [-0.13313, 0.36687, 0, 0],
        "8641": [-0.13313, 0.36687, 0, 0],
        "8652": [0.011, 0.671, 0, 0],
        "8656": [-0.13313, 0.36687, 0, 0],
        "8657": [0.19444, 0.69444, 0, 0],
        "8658": [-0.13313, 0.36687, 0, 0],
        "8659": [0.19444, 0.69444, 0, 0],
        "8660": [-0.13313, 0.36687, 0, 0],
        "8661": [0.25, 0.75, 0, 0],
        "8704": [0, 0.69444, 0, 0],
        "8706": [0, 0.69444, 0.05556, 0.08334],
        "8707": [0, 0.69444, 0, 0],
        "8709": [0.05556, 0.75, 0, 0],
        "8711": [0, 0.68333, 0, 0],
        "8712": [0.0391, 0.5391, 0, 0],
        "8715": [0.0391, 0.5391, 0, 0],
        "8722": [0.08333, 0.58333, 0, 0],
        "8723": [0.08333, 0.58333, 0, 0],
        "8725": [0.25, 0.75, 0, 0],
        "8726": [0.25, 0.75, 0, 0],
        "8727": [-0.03472, 0.46528, 0, 0],
        "8728": [-0.05555, 0.44445, 0, 0],
        "8729": [-0.05555, 0.44445, 0, 0],
        "8730": [0.2, 0.8, 0, 0],
        "8733": [0, 0.43056, 0, 0],
        "8734": [0, 0.43056, 0, 0],
        "8736": [0, 0.69224, 0, 0],
        "8739": [0.25, 0.75, 0, 0],
        "8741": [0.25, 0.75, 0, 0],
        "8743": [0, 0.55556, 0, 0],
        "8744": [0, 0.55556, 0, 0],
        "8745": [0, 0.55556, 0, 0],
        "8746": [0, 0.55556, 0, 0],
        "8747": [0.19444, 0.69444, 0.11111, 0],
        "8764": [-0.13313, 0.36687, 0, 0],
        "8768": [0.19444, 0.69444, 0, 0],
        "8771": [-0.03625, 0.46375, 0, 0],
        "8773": [-0.022, 0.589, 0, 0],
        "8776": [-0.01688, 0.48312, 0, 0],
        "8781": [-0.03625, 0.46375, 0, 0],
        "8784": [-0.133, 0.67, 0, 0],
        "8800": [0.215, 0.716, 0, 0],
        "8801": [-0.03625, 0.46375, 0, 0],
        "8804": [0.13597, 0.63597, 0, 0],
        "8805": [0.13597, 0.63597, 0, 0],
        "8810": [0.0391, 0.5391, 0, 0],
        "8811": [0.0391, 0.5391, 0, 0],
        "8826": [0.0391, 0.5391, 0, 0],
        "8827": [0.0391, 0.5391, 0, 0],
        "8834": [0.0391, 0.5391, 0, 0],
        "8835": [0.0391, 0.5391, 0, 0],
        "8838": [0.13597, 0.63597, 0, 0],
        "8839": [0.13597, 0.63597, 0, 0],
        "8846": [0, 0.55556, 0, 0],
        "8849": [0.13597, 0.63597, 0, 0],
        "8850": [0.13597, 0.63597, 0, 0],
        "8851": [0, 0.55556, 0, 0],
        "8852": [0, 0.55556, 0, 0],
        "8853": [0.08333, 0.58333, 0, 0],
        "8854": [0.08333, 0.58333, 0, 0],
        "8855": [0.08333, 0.58333, 0, 0],
        "8856": [0.08333, 0.58333, 0, 0],
        "8857": [0.08333, 0.58333, 0, 0],
        "8866": [0, 0.69444, 0, 0],
        "8867": [0, 0.69444, 0, 0],
        "8868": [0, 0.69444, 0, 0],
        "8869": [0, 0.69444, 0, 0],
        "8872": [0.249, 0.75, 0, 0],
        "8900": [-0.05555, 0.44445, 0, 0],
        "8901": [-0.05555, 0.44445, 0, 0],
        "8902": [-0.03472, 0.46528, 0, 0],
        "8904": [5e-3, 0.505, 0, 0],
        "8942": [0.03, 0.9, 0, 0],
        "8943": [-0.19, 0.31, 0, 0],
        "8945": [-0.1, 0.82, 0, 0],
        "8968": [0.25, 0.75, 0, 0],
        "8969": [0.25, 0.75, 0, 0],
        "8970": [0.25, 0.75, 0, 0],
        "8971": [0.25, 0.75, 0, 0],
        "8994": [-0.14236, 0.35764, 0, 0],
        "8995": [-0.14236, 0.35764, 0, 0],
        "9136": [0.244, 0.744, 0, 0],
        "9137": [0.244, 0.744, 0, 0],
        "9651": [0.19444, 0.69444, 0, 0],
        "9657": [-0.03472, 0.46528, 0, 0],
        "9661": [0.19444, 0.69444, 0, 0],
        "9667": [-0.03472, 0.46528, 0, 0],
        "9711": [0.19444, 0.69444, 0, 0],
        "9824": [0.12963, 0.69444, 0, 0],
        "9825": [0.12963, 0.69444, 0, 0],
        "9826": [0.12963, 0.69444, 0, 0],
        "9827": [0.12963, 0.69444, 0, 0],
        "9837": [0, 0.75, 0, 0],
        "9838": [0.19444, 0.69444, 0, 0],
        "9839": [0.19444, 0.69444, 0, 0],
        "10216": [0.25, 0.75, 0, 0],
        "10217": [0.25, 0.75, 0, 0],
        "10222": [0.244, 0.744, 0, 0],
        "10223": [0.244, 0.744, 0, 0],
        "10229": [0.011, 0.511, 0, 0],
        "10230": [0.011, 0.511, 0, 0],
        "10231": [0.011, 0.511, 0, 0],
        "10232": [0.024, 0.525, 0, 0],
        "10233": [0.024, 0.525, 0, 0],
        "10234": [0.024, 0.525, 0, 0],
        "10236": [0.011, 0.511, 0, 0],
        "10815": [0, 0.68333, 0, 0],
        "10927": [0.13597, 0.63597, 0, 0],
        "10928": [0.13597, 0.63597, 0, 0]
      },
      "Math-BoldItalic": {
        "47": [0.19444, 0.69444, 0, 0],
        "65": [0, 0.68611, 0, 0],
        "66": [0, 0.68611, 0.04835, 0],
        "67": [0, 0.68611, 0.06979, 0],
        "68": [0, 0.68611, 0.03194, 0],
        "69": [0, 0.68611, 0.05451, 0],
        "70": [0, 0.68611, 0.15972, 0],
        "71": [0, 0.68611, 0, 0],
        "72": [0, 0.68611, 0.08229, 0],
        "73": [0, 0.68611, 0.07778, 0],
        "74": [0, 0.68611, 0.10069, 0],
        "75": [0, 0.68611, 0.06979, 0],
        "76": [0, 0.68611, 0, 0],
        "77": [0, 0.68611, 0.11424, 0],
        "78": [0, 0.68611, 0.11424, 0],
        "79": [0, 0.68611, 0.03194, 0],
        "80": [0, 0.68611, 0.15972, 0],
        "81": [0.19444, 0.68611, 0, 0],
        "82": [0, 0.68611, 421e-5, 0],
        "83": [0, 0.68611, 0.05382, 0],
        "84": [0, 0.68611, 0.15972, 0],
        "85": [0, 0.68611, 0.11424, 0],
        "86": [0, 0.68611, 0.25555, 0],
        "87": [0, 0.68611, 0.15972, 0],
        "88": [0, 0.68611, 0.07778, 0],
        "89": [0, 0.68611, 0.25555, 0],
        "90": [0, 0.68611, 0.06979, 0],
        "97": [0, 0.44444, 0, 0],
        "98": [0, 0.69444, 0, 0],
        "99": [0, 0.44444, 0, 0],
        "100": [0, 0.69444, 0, 0],
        "101": [0, 0.44444, 0, 0],
        "102": [0.19444, 0.69444, 0.11042, 0],
        "103": [0.19444, 0.44444, 0.03704, 0],
        "104": [0, 0.69444, 0, 0],
        "105": [0, 0.69326, 0, 0],
        "106": [0.19444, 0.69326, 0.0622, 0],
        "107": [0, 0.69444, 0.01852, 0],
        "108": [0, 0.69444, 88e-4, 0],
        "109": [0, 0.44444, 0, 0],
        "110": [0, 0.44444, 0, 0],
        "111": [0, 0.44444, 0, 0],
        "112": [0.19444, 0.44444, 0, 0],
        "113": [0.19444, 0.44444, 0.03704, 0],
        "114": [0, 0.44444, 0.03194, 0],
        "115": [0, 0.44444, 0, 0],
        "116": [0, 0.63492, 0, 0],
        "117": [0, 0.44444, 0, 0],
        "118": [0, 0.44444, 0.03704, 0],
        "119": [0, 0.44444, 0.02778, 0],
        "120": [0, 0.44444, 0, 0],
        "121": [0.19444, 0.44444, 0.03704, 0],
        "122": [0, 0.44444, 0.04213, 0],
        "915": [0, 0.68611, 0.15972, 0],
        "916": [0, 0.68611, 0, 0],
        "920": [0, 0.68611, 0.03194, 0],
        "923": [0, 0.68611, 0, 0],
        "926": [0, 0.68611, 0.07458, 0],
        "928": [0, 0.68611, 0.08229, 0],
        "931": [0, 0.68611, 0.05451, 0],
        "933": [0, 0.68611, 0.15972, 0],
        "934": [0, 0.68611, 0, 0],
        "936": [0, 0.68611, 0.11653, 0],
        "937": [0, 0.68611, 0.04835, 0],
        "945": [0, 0.44444, 0, 0],
        "946": [0.19444, 0.69444, 0.03403, 0],
        "947": [0.19444, 0.44444, 0.06389, 0],
        "948": [0, 0.69444, 0.03819, 0],
        "949": [0, 0.44444, 0, 0],
        "950": [0.19444, 0.69444, 0.06215, 0],
        "951": [0.19444, 0.44444, 0.03704, 0],
        "952": [0, 0.69444, 0.03194, 0],
        "953": [0, 0.44444, 0, 0],
        "954": [0, 0.44444, 0, 0],
        "955": [0, 0.69444, 0, 0],
        "956": [0.19444, 0.44444, 0, 0],
        "957": [0, 0.44444, 0.06898, 0],
        "958": [0.19444, 0.69444, 0.03021, 0],
        "959": [0, 0.44444, 0, 0],
        "960": [0, 0.44444, 0.03704, 0],
        "961": [0.19444, 0.44444, 0, 0],
        "962": [0.09722, 0.44444, 0.07917, 0],
        "963": [0, 0.44444, 0.03704, 0],
        "964": [0, 0.44444, 0.13472, 0],
        "965": [0, 0.44444, 0.03704, 0],
        "966": [0.19444, 0.44444, 0, 0],
        "967": [0.19444, 0.44444, 0, 0],
        "968": [0.19444, 0.69444, 0.03704, 0],
        "969": [0, 0.44444, 0.03704, 0],
        "977": [0, 0.69444, 0, 0],
        "981": [0.19444, 0.69444, 0, 0],
        "982": [0, 0.44444, 0.03194, 0],
        "1009": [0.19444, 0.44444, 0, 0],
        "1013": [0, 0.44444, 0, 0]
      },
      "Math-Italic": {
        "47": [0.19444, 0.69444, 0, 0],
        "65": [0, 0.68333, 0, 0.13889],
        "66": [0, 0.68333, 0.05017, 0.08334],
        "67": [0, 0.68333, 0.07153, 0.08334],
        "68": [0, 0.68333, 0.02778, 0.05556],
        "69": [0, 0.68333, 0.05764, 0.08334],
        "70": [0, 0.68333, 0.13889, 0.08334],
        "71": [0, 0.68333, 0, 0.08334],
        "72": [0, 0.68333, 0.08125, 0.05556],
        "73": [0, 0.68333, 0.07847, 0.11111],
        "74": [0, 0.68333, 0.09618, 0.16667],
        "75": [0, 0.68333, 0.07153, 0.05556],
        "76": [0, 0.68333, 0, 0.02778],
        "77": [0, 0.68333, 0.10903, 0.08334],
        "78": [0, 0.68333, 0.10903, 0.08334],
        "79": [0, 0.68333, 0.02778, 0.08334],
        "80": [0, 0.68333, 0.13889, 0.08334],
        "81": [0.19444, 0.68333, 0, 0.08334],
        "82": [0, 0.68333, 773e-5, 0.08334],
        "83": [0, 0.68333, 0.05764, 0.08334],
        "84": [0, 0.68333, 0.13889, 0.08334],
        "85": [0, 0.68333, 0.10903, 0.02778],
        "86": [0, 0.68333, 0.22222, 0],
        "87": [0, 0.68333, 0.13889, 0],
        "88": [0, 0.68333, 0.07847, 0.08334],
        "89": [0, 0.68333, 0.22222, 0],
        "90": [0, 0.68333, 0.07153, 0.08334],
        "97": [0, 0.43056, 0, 0],
        "98": [0, 0.69444, 0, 0],
        "99": [0, 0.43056, 0, 0.05556],
        "100": [0, 0.69444, 0, 0.16667],
        "101": [0, 0.43056, 0, 0.05556],
        "102": [0.19444, 0.69444, 0.10764, 0.16667],
        "103": [0.19444, 0.43056, 0.03588, 0.02778],
        "104": [0, 0.69444, 0, 0],
        "105": [0, 0.65952, 0, 0],
        "106": [0.19444, 0.65952, 0.05724, 0],
        "107": [0, 0.69444, 0.03148, 0],
        "108": [0, 0.69444, 0.01968, 0.08334],
        "109": [0, 0.43056, 0, 0],
        "110": [0, 0.43056, 0, 0],
        "111": [0, 0.43056, 0, 0.05556],
        "112": [0.19444, 0.43056, 0, 0.08334],
        "113": [0.19444, 0.43056, 0.03588, 0.08334],
        "114": [0, 0.43056, 0.02778, 0.05556],
        "115": [0, 0.43056, 0, 0.05556],
        "116": [0, 0.61508, 0, 0.08334],
        "117": [0, 0.43056, 0, 0.02778],
        "118": [0, 0.43056, 0.03588, 0.02778],
        "119": [0, 0.43056, 0.02691, 0.08334],
        "120": [0, 0.43056, 0, 0.02778],
        "121": [0.19444, 0.43056, 0.03588, 0.05556],
        "122": [0, 0.43056, 0.04398, 0.05556],
        "915": [0, 0.68333, 0.13889, 0.08334],
        "916": [0, 0.68333, 0, 0.16667],
        "920": [0, 0.68333, 0.02778, 0.08334],
        "923": [0, 0.68333, 0, 0.16667],
        "926": [0, 0.68333, 0.07569, 0.08334],
        "928": [0, 0.68333, 0.08125, 0.05556],
        "931": [0, 0.68333, 0.05764, 0.08334],
        "933": [0, 0.68333, 0.13889, 0.05556],
        "934": [0, 0.68333, 0, 0.08334],
        "936": [0, 0.68333, 0.11, 0.05556],
        "937": [0, 0.68333, 0.05017, 0.08334],
        "945": [0, 0.43056, 37e-4, 0.02778],
        "946": [0.19444, 0.69444, 0.05278, 0.08334],
        "947": [0.19444, 0.43056, 0.05556, 0],
        "948": [0, 0.69444, 0.03785, 0.05556],
        "949": [0, 0.43056, 0, 0.08334],
        "950": [0.19444, 0.69444, 0.07378, 0.08334],
        "951": [0.19444, 0.43056, 0.03588, 0.05556],
        "952": [0, 0.69444, 0.02778, 0.08334],
        "953": [0, 0.43056, 0, 0.05556],
        "954": [0, 0.43056, 0, 0],
        "955": [0, 0.69444, 0, 0],
        "956": [0.19444, 0.43056, 0, 0.02778],
        "957": [0, 0.43056, 0.06366, 0.02778],
        "958": [0.19444, 0.69444, 0.04601, 0.11111],
        "959": [0, 0.43056, 0, 0.05556],
        "960": [0, 0.43056, 0.03588, 0],
        "961": [0.19444, 0.43056, 0, 0.08334],
        "962": [0.09722, 0.43056, 0.07986, 0.08334],
        "963": [0, 0.43056, 0.03588, 0],
        "964": [0, 0.43056, 0.1132, 0.02778],
        "965": [0, 0.43056, 0.03588, 0.02778],
        "966": [0.19444, 0.43056, 0, 0.08334],
        "967": [0.19444, 0.43056, 0, 0.05556],
        "968": [0.19444, 0.69444, 0.03588, 0.11111],
        "969": [0, 0.43056, 0.03588, 0],
        "977": [0, 0.69444, 0, 0.08334],
        "981": [0.19444, 0.69444, 0, 0.08334],
        "982": [0, 0.43056, 0.02778, 0],
        "1009": [0.19444, 0.43056, 0, 0.08334],
        "1013": [0, 0.43056, 0, 0.05556]
      },
      "Math-Regular": {
        "65": [0, 0.68333, 0, 0.13889],
        "66": [0, 0.68333, 0.05017, 0.08334],
        "67": [0, 0.68333, 0.07153, 0.08334],
        "68": [0, 0.68333, 0.02778, 0.05556],
        "69": [0, 0.68333, 0.05764, 0.08334],
        "70": [0, 0.68333, 0.13889, 0.08334],
        "71": [0, 0.68333, 0, 0.08334],
        "72": [0, 0.68333, 0.08125, 0.05556],
        "73": [0, 0.68333, 0.07847, 0.11111],
        "74": [0, 0.68333, 0.09618, 0.16667],
        "75": [0, 0.68333, 0.07153, 0.05556],
        "76": [0, 0.68333, 0, 0.02778],
        "77": [0, 0.68333, 0.10903, 0.08334],
        "78": [0, 0.68333, 0.10903, 0.08334],
        "79": [0, 0.68333, 0.02778, 0.08334],
        "80": [0, 0.68333, 0.13889, 0.08334],
        "81": [0.19444, 0.68333, 0, 0.08334],
        "82": [0, 0.68333, 773e-5, 0.08334],
        "83": [0, 0.68333, 0.05764, 0.08334],
        "84": [0, 0.68333, 0.13889, 0.08334],
        "85": [0, 0.68333, 0.10903, 0.02778],
        "86": [0, 0.68333, 0.22222, 0],
        "87": [0, 0.68333, 0.13889, 0],
        "88": [0, 0.68333, 0.07847, 0.08334],
        "89": [0, 0.68333, 0.22222, 0],
        "90": [0, 0.68333, 0.07153, 0.08334],
        "97": [0, 0.43056, 0, 0],
        "98": [0, 0.69444, 0, 0],
        "99": [0, 0.43056, 0, 0.05556],
        "100": [0, 0.69444, 0, 0.16667],
        "101": [0, 0.43056, 0, 0.05556],
        "102": [0.19444, 0.69444, 0.10764, 0.16667],
        "103": [0.19444, 0.43056, 0.03588, 0.02778],
        "104": [0, 0.69444, 0, 0],
        "105": [0, 0.65952, 0, 0],
        "106": [0.19444, 0.65952, 0.05724, 0],
        "107": [0, 0.69444, 0.03148, 0],
        "108": [0, 0.69444, 0.01968, 0.08334],
        "109": [0, 0.43056, 0, 0],
        "110": [0, 0.43056, 0, 0],
        "111": [0, 0.43056, 0, 0.05556],
        "112": [0.19444, 0.43056, 0, 0.08334],
        "113": [0.19444, 0.43056, 0.03588, 0.08334],
        "114": [0, 0.43056, 0.02778, 0.05556],
        "115": [0, 0.43056, 0, 0.05556],
        "116": [0, 0.61508, 0, 0.08334],
        "117": [0, 0.43056, 0, 0.02778],
        "118": [0, 0.43056, 0.03588, 0.02778],
        "119": [0, 0.43056, 0.02691, 0.08334],
        "120": [0, 0.43056, 0, 0.02778],
        "121": [0.19444, 0.43056, 0.03588, 0.05556],
        "122": [0, 0.43056, 0.04398, 0.05556],
        "915": [0, 0.68333, 0.13889, 0.08334],
        "916": [0, 0.68333, 0, 0.16667],
        "920": [0, 0.68333, 0.02778, 0.08334],
        "923": [0, 0.68333, 0, 0.16667],
        "926": [0, 0.68333, 0.07569, 0.08334],
        "928": [0, 0.68333, 0.08125, 0.05556],
        "931": [0, 0.68333, 0.05764, 0.08334],
        "933": [0, 0.68333, 0.13889, 0.05556],
        "934": [0, 0.68333, 0, 0.08334],
        "936": [0, 0.68333, 0.11, 0.05556],
        "937": [0, 0.68333, 0.05017, 0.08334],
        "945": [0, 0.43056, 37e-4, 0.02778],
        "946": [0.19444, 0.69444, 0.05278, 0.08334],
        "947": [0.19444, 0.43056, 0.05556, 0],
        "948": [0, 0.69444, 0.03785, 0.05556],
        "949": [0, 0.43056, 0, 0.08334],
        "950": [0.19444, 0.69444, 0.07378, 0.08334],
        "951": [0.19444, 0.43056, 0.03588, 0.05556],
        "952": [0, 0.69444, 0.02778, 0.08334],
        "953": [0, 0.43056, 0, 0.05556],
        "954": [0, 0.43056, 0, 0],
        "955": [0, 0.69444, 0, 0],
        "956": [0.19444, 0.43056, 0, 0.02778],
        "957": [0, 0.43056, 0.06366, 0.02778],
        "958": [0.19444, 0.69444, 0.04601, 0.11111],
        "959": [0, 0.43056, 0, 0.05556],
        "960": [0, 0.43056, 0.03588, 0],
        "961": [0.19444, 0.43056, 0, 0.08334],
        "962": [0.09722, 0.43056, 0.07986, 0.08334],
        "963": [0, 0.43056, 0.03588, 0],
        "964": [0, 0.43056, 0.1132, 0.02778],
        "965": [0, 0.43056, 0.03588, 0.02778],
        "966": [0.19444, 0.43056, 0, 0.08334],
        "967": [0.19444, 0.43056, 0, 0.05556],
        "968": [0.19444, 0.69444, 0.03588, 0.11111],
        "969": [0, 0.43056, 0.03588, 0],
        "977": [0, 0.69444, 0, 0.08334],
        "981": [0.19444, 0.69444, 0, 0.08334],
        "982": [0, 0.43056, 0.02778, 0],
        "1009": [0.19444, 0.43056, 0, 0.08334],
        "1013": [0, 0.43056, 0, 0.05556]
      },
      "SansSerif-Regular": {
        "33": [0, 0.69444, 0, 0],
        "34": [0, 0.69444, 0, 0],
        "35": [0.19444, 0.69444, 0, 0],
        "36": [0.05556, 0.75, 0, 0],
        "37": [0.05556, 0.75, 0, 0],
        "38": [0, 0.69444, 0, 0],
        "39": [0, 0.69444, 0, 0],
        "40": [0.25, 0.75, 0, 0],
        "41": [0.25, 0.75, 0, 0],
        "42": [0, 0.75, 0, 0],
        "43": [0.08333, 0.58333, 0, 0],
        "44": [0.125, 0.08333, 0, 0],
        "45": [0, 0.44444, 0, 0],
        "46": [0, 0.08333, 0, 0],
        "47": [0.25, 0.75, 0, 0],
        "48": [0, 0.65556, 0, 0],
        "49": [0, 0.65556, 0, 0],
        "50": [0, 0.65556, 0, 0],
        "51": [0, 0.65556, 0, 0],
        "52": [0, 0.65556, 0, 0],
        "53": [0, 0.65556, 0, 0],
        "54": [0, 0.65556, 0, 0],
        "55": [0, 0.65556, 0, 0],
        "56": [0, 0.65556, 0, 0],
        "57": [0, 0.65556, 0, 0],
        "58": [0, 0.44444, 0, 0],
        "59": [0.125, 0.44444, 0, 0],
        "61": [-0.13, 0.37, 0, 0],
        "63": [0, 0.69444, 0, 0],
        "64": [0, 0.69444, 0, 0],
        "65": [0, 0.69444, 0, 0],
        "66": [0, 0.69444, 0, 0],
        "67": [0, 0.69444, 0, 0],
        "68": [0, 0.69444, 0, 0],
        "69": [0, 0.69444, 0, 0],
        "70": [0, 0.69444, 0, 0],
        "71": [0, 0.69444, 0, 0],
        "72": [0, 0.69444, 0, 0],
        "73": [0, 0.69444, 0, 0],
        "74": [0, 0.69444, 0, 0],
        "75": [0, 0.69444, 0, 0],
        "76": [0, 0.69444, 0, 0],
        "77": [0, 0.69444, 0, 0],
        "78": [0, 0.69444, 0, 0],
        "79": [0, 0.69444, 0, 0],
        "80": [0, 0.69444, 0, 0],
        "81": [0.125, 0.69444, 0, 0],
        "82": [0, 0.69444, 0, 0],
        "83": [0, 0.69444, 0, 0],
        "84": [0, 0.69444, 0, 0],
        "85": [0, 0.69444, 0, 0],
        "86": [0, 0.69444, 0.01389, 0],
        "87": [0, 0.69444, 0.01389, 0],
        "88": [0, 0.69444, 0, 0],
        "89": [0, 0.69444, 0.025, 0],
        "90": [0, 0.69444, 0, 0],
        "91": [0.25, 0.75, 0, 0],
        "93": [0.25, 0.75, 0, 0],
        "94": [0, 0.69444, 0, 0],
        "95": [0.35, 0.09444, 0.02778, 0],
        "97": [0, 0.44444, 0, 0],
        "98": [0, 0.69444, 0, 0],
        "99": [0, 0.44444, 0, 0],
        "100": [0, 0.69444, 0, 0],
        "101": [0, 0.44444, 0, 0],
        "102": [0, 0.69444, 0.06944, 0],
        "103": [0.19444, 0.44444, 0.01389, 0],
        "104": [0, 0.69444, 0, 0],
        "105": [0, 0.67937, 0, 0],
        "106": [0.19444, 0.67937, 0, 0],
        "107": [0, 0.69444, 0, 0],
        "108": [0, 0.69444, 0, 0],
        "109": [0, 0.44444, 0, 0],
        "110": [0, 0.44444, 0, 0],
        "111": [0, 0.44444, 0, 0],
        "112": [0.19444, 0.44444, 0, 0],
        "113": [0.19444, 0.44444, 0, 0],
        "114": [0, 0.44444, 0.01389, 0],
        "115": [0, 0.44444, 0, 0],
        "116": [0, 0.57143, 0, 0],
        "117": [0, 0.44444, 0, 0],
        "118": [0, 0.44444, 0.01389, 0],
        "119": [0, 0.44444, 0.01389, 0],
        "120": [0, 0.44444, 0, 0],
        "121": [0.19444, 0.44444, 0.01389, 0],
        "122": [0, 0.44444, 0, 0],
        "126": [0.35, 0.32659, 0, 0],
        "305": [0, 0.44444, 0, 0],
        "567": [0.19444, 0.44444, 0, 0],
        "768": [0, 0.69444, 0, 0],
        "769": [0, 0.69444, 0, 0],
        "770": [0, 0.69444, 0, 0],
        "771": [0, 0.67659, 0, 0],
        "772": [0, 0.60889, 0, 0],
        "774": [0, 0.69444, 0, 0],
        "775": [0, 0.67937, 0, 0],
        "776": [0, 0.67937, 0, 0],
        "778": [0, 0.69444, 0, 0],
        "779": [0, 0.69444, 0, 0],
        "780": [0, 0.63194, 0, 0],
        "915": [0, 0.69444, 0, 0],
        "916": [0, 0.69444, 0, 0],
        "920": [0, 0.69444, 0, 0],
        "923": [0, 0.69444, 0, 0],
        "926": [0, 0.69444, 0, 0],
        "928": [0, 0.69444, 0, 0],
        "931": [0, 0.69444, 0, 0],
        "933": [0, 0.69444, 0, 0],
        "934": [0, 0.69444, 0, 0],
        "936": [0, 0.69444, 0, 0],
        "937": [0, 0.69444, 0, 0],
        "8211": [0, 0.44444, 0.02778, 0],
        "8212": [0, 0.44444, 0.02778, 0],
        "8216": [0, 0.69444, 0, 0],
        "8217": [0, 0.69444, 0, 0],
        "8220": [0, 0.69444, 0, 0],
        "8221": [0, 0.69444, 0, 0]
      },
      "Script-Regular": {
        "65": [0, 0.7, 0.22925, 0],
        "66": [0, 0.7, 0.04087, 0],
        "67": [0, 0.7, 0.1689, 0],
        "68": [0, 0.7, 0.09371, 0],
        "69": [0, 0.7, 0.18583, 0],
        "70": [0, 0.7, 0.13634, 0],
        "71": [0, 0.7, 0.17322, 0],
        "72": [0, 0.7, 0.29694, 0],
        "73": [0, 0.7, 0.19189, 0],
        "74": [0.27778, 0.7, 0.19189, 0],
        "75": [0, 0.7, 0.31259, 0],
        "76": [0, 0.7, 0.19189, 0],
        "77": [0, 0.7, 0.15981, 0],
        "78": [0, 0.7, 0.3525, 0],
        "79": [0, 0.7, 0.08078, 0],
        "80": [0, 0.7, 0.08078, 0],
        "81": [0, 0.7, 0.03305, 0],
        "82": [0, 0.7, 0.06259, 0],
        "83": [0, 0.7, 0.19189, 0],
        "84": [0, 0.7, 0.29087, 0],
        "85": [0, 0.7, 0.25815, 0],
        "86": [0, 0.7, 0.27523, 0],
        "87": [0, 0.7, 0.27523, 0],
        "88": [0, 0.7, 0.26006, 0],
        "89": [0, 0.7, 0.2939, 0],
        "90": [0, 0.7, 0.24037, 0]
      },
      "Size1-Regular": {
        "40": [0.35001, 0.85, 0, 0],
        "41": [0.35001, 0.85, 0, 0],
        "47": [0.35001, 0.85, 0, 0],
        "91": [0.35001, 0.85, 0, 0],
        "92": [0.35001, 0.85, 0, 0],
        "93": [0.35001, 0.85, 0, 0],
        "123": [0.35001, 0.85, 0, 0],
        "125": [0.35001, 0.85, 0, 0],
        "710": [0, 0.72222, 0, 0],
        "732": [0, 0.72222, 0, 0],
        "770": [0, 0.72222, 0, 0],
        "771": [0, 0.72222, 0, 0],
        "8214": [-99e-5, 0.601, 0, 0],
        "8593": [1e-5, 0.6, 0, 0],
        "8595": [1e-5, 0.6, 0, 0],
        "8657": [1e-5, 0.6, 0, 0],
        "8659": [1e-5, 0.6, 0, 0],
        "8719": [0.25001, 0.75, 0, 0],
        "8720": [0.25001, 0.75, 0, 0],
        "8721": [0.25001, 0.75, 0, 0],
        "8730": [0.35001, 0.85, 0, 0],
        "8739": [-599e-5, 0.606, 0, 0],
        "8741": [-599e-5, 0.606, 0, 0],
        "8747": [0.30612, 0.805, 0.19445, 0],
        "8748": [0.306, 0.805, 0.19445, 0],
        "8749": [0.306, 0.805, 0.19445, 0],
        "8750": [0.30612, 0.805, 0.19445, 0],
        "8896": [0.25001, 0.75, 0, 0],
        "8897": [0.25001, 0.75, 0, 0],
        "8898": [0.25001, 0.75, 0, 0],
        "8899": [0.25001, 0.75, 0, 0],
        "8968": [0.35001, 0.85, 0, 0],
        "8969": [0.35001, 0.85, 0, 0],
        "8970": [0.35001, 0.85, 0, 0],
        "8971": [0.35001, 0.85, 0, 0],
        "9168": [-99e-5, 0.601, 0, 0],
        "10216": [0.35001, 0.85, 0, 0],
        "10217": [0.35001, 0.85, 0, 0],
        "10752": [0.25001, 0.75, 0, 0],
        "10753": [0.25001, 0.75, 0, 0],
        "10754": [0.25001, 0.75, 0, 0],
        "10756": [0.25001, 0.75, 0, 0],
        "10758": [0.25001, 0.75, 0, 0]
      },
      "Size2-Regular": {
        "40": [0.65002, 1.15, 0, 0],
        "41": [0.65002, 1.15, 0, 0],
        "47": [0.65002, 1.15, 0, 0],
        "91": [0.65002, 1.15, 0, 0],
        "92": [0.65002, 1.15, 0, 0],
        "93": [0.65002, 1.15, 0, 0],
        "123": [0.65002, 1.15, 0, 0],
        "125": [0.65002, 1.15, 0, 0],
        "710": [0, 0.75, 0, 0],
        "732": [0, 0.75, 0, 0],
        "770": [0, 0.75, 0, 0],
        "771": [0, 0.75, 0, 0],
        "8719": [0.55001, 1.05, 0, 0],
        "8720": [0.55001, 1.05, 0, 0],
        "8721": [0.55001, 1.05, 0, 0],
        "8730": [0.65002, 1.15, 0, 0],
        "8747": [0.86225, 1.36, 0.44445, 0],
        "8748": [0.862, 1.36, 0.44445, 0],
        "8749": [0.862, 1.36, 0.44445, 0],
        "8750": [0.86225, 1.36, 0.44445, 0],
        "8896": [0.55001, 1.05, 0, 0],
        "8897": [0.55001, 1.05, 0, 0],
        "8898": [0.55001, 1.05, 0, 0],
        "8899": [0.55001, 1.05, 0, 0],
        "8968": [0.65002, 1.15, 0, 0],
        "8969": [0.65002, 1.15, 0, 0],
        "8970": [0.65002, 1.15, 0, 0],
        "8971": [0.65002, 1.15, 0, 0],
        "10216": [0.65002, 1.15, 0, 0],
        "10217": [0.65002, 1.15, 0, 0],
        "10752": [0.55001, 1.05, 0, 0],
        "10753": [0.55001, 1.05, 0, 0],
        "10754": [0.55001, 1.05, 0, 0],
        "10756": [0.55001, 1.05, 0, 0],
        "10758": [0.55001, 1.05, 0, 0]
      },
      "Size3-Regular": {
        "40": [0.95003, 1.45, 0, 0],
        "41": [0.95003, 1.45, 0, 0],
        "47": [0.95003, 1.45, 0, 0],
        "91": [0.95003, 1.45, 0, 0],
        "92": [0.95003, 1.45, 0, 0],
        "93": [0.95003, 1.45, 0, 0],
        "123": [0.95003, 1.45, 0, 0],
        "125": [0.95003, 1.45, 0, 0],
        "710": [0, 0.75, 0, 0],
        "732": [0, 0.75, 0, 0],
        "770": [0, 0.75, 0, 0],
        "771": [0, 0.75, 0, 0],
        "8730": [0.95003, 1.45, 0, 0],
        "8968": [0.95003, 1.45, 0, 0],
        "8969": [0.95003, 1.45, 0, 0],
        "8970": [0.95003, 1.45, 0, 0],
        "8971": [0.95003, 1.45, 0, 0],
        "10216": [0.95003, 1.45, 0, 0],
        "10217": [0.95003, 1.45, 0, 0]
      },
      "Size4-Regular": {
        "40": [1.25003, 1.75, 0, 0],
        "41": [1.25003, 1.75, 0, 0],
        "47": [1.25003, 1.75, 0, 0],
        "91": [1.25003, 1.75, 0, 0],
        "92": [1.25003, 1.75, 0, 0],
        "93": [1.25003, 1.75, 0, 0],
        "123": [1.25003, 1.75, 0, 0],
        "125": [1.25003, 1.75, 0, 0],
        "710": [0, 0.825, 0, 0],
        "732": [0, 0.825, 0, 0],
        "770": [0, 0.825, 0, 0],
        "771": [0, 0.825, 0, 0],
        "8730": [1.25003, 1.75, 0, 0],
        "8968": [1.25003, 1.75, 0, 0],
        "8969": [1.25003, 1.75, 0, 0],
        "8970": [1.25003, 1.75, 0, 0],
        "8971": [1.25003, 1.75, 0, 0],
        "9115": [0.64502, 1.155, 0, 0],
        "9116": [1e-5, 0.6, 0, 0],
        "9117": [0.64502, 1.155, 0, 0],
        "9118": [0.64502, 1.155, 0, 0],
        "9119": [1e-5, 0.6, 0, 0],
        "9120": [0.64502, 1.155, 0, 0],
        "9121": [0.64502, 1.155, 0, 0],
        "9122": [-99e-5, 0.601, 0, 0],
        "9123": [0.64502, 1.155, 0, 0],
        "9124": [0.64502, 1.155, 0, 0],
        "9125": [-99e-5, 0.601, 0, 0],
        "9126": [0.64502, 1.155, 0, 0],
        "9127": [1e-5, 0.9, 0, 0],
        "9128": [0.65002, 1.15, 0, 0],
        "9129": [0.90001, 0, 0, 0],
        "9130": [0, 0.3, 0, 0],
        "9131": [1e-5, 0.9, 0, 0],
        "9132": [0.65002, 1.15, 0, 0],
        "9133": [0.90001, 0, 0, 0],
        "9143": [0.88502, 0.915, 0, 0],
        "10216": [1.25003, 1.75, 0, 0],
        "10217": [1.25003, 1.75, 0, 0],
        "57344": [-499e-5, 0.605, 0, 0],
        "57345": [-499e-5, 0.605, 0, 0],
        "57680": [0, 0.12, 0, 0],
        "57681": [0, 0.12, 0, 0],
        "57682": [0, 0.12, 0, 0],
        "57683": [0, 0.12, 0, 0]
      },
      "Typewriter-Regular": {
        "33": [0, 0.61111, 0, 0],
        "34": [0, 0.61111, 0, 0],
        "35": [0, 0.61111, 0, 0],
        "36": [0.08333, 0.69444, 0, 0],
        "37": [0.08333, 0.69444, 0, 0],
        "38": [0, 0.61111, 0, 0],
        "39": [0, 0.61111, 0, 0],
        "40": [0.08333, 0.69444, 0, 0],
        "41": [0.08333, 0.69444, 0, 0],
        "42": [0, 0.52083, 0, 0],
        "43": [-0.08056, 0.53055, 0, 0],
        "44": [0.13889, 0.125, 0, 0],
        "45": [-0.08056, 0.53055, 0, 0],
        "46": [0, 0.125, 0, 0],
        "47": [0.08333, 0.69444, 0, 0],
        "48": [0, 0.61111, 0, 0],
        "49": [0, 0.61111, 0, 0],
        "50": [0, 0.61111, 0, 0],
        "51": [0, 0.61111, 0, 0],
        "52": [0, 0.61111, 0, 0],
        "53": [0, 0.61111, 0, 0],
        "54": [0, 0.61111, 0, 0],
        "55": [0, 0.61111, 0, 0],
        "56": [0, 0.61111, 0, 0],
        "57": [0, 0.61111, 0, 0],
        "58": [0, 0.43056, 0, 0],
        "59": [0.13889, 0.43056, 0, 0],
        "60": [-0.05556, 0.55556, 0, 0],
        "61": [-0.19549, 0.41562, 0, 0],
        "62": [-0.05556, 0.55556, 0, 0],
        "63": [0, 0.61111, 0, 0],
        "64": [0, 0.61111, 0, 0],
        "65": [0, 0.61111, 0, 0],
        "66": [0, 0.61111, 0, 0],
        "67": [0, 0.61111, 0, 0],
        "68": [0, 0.61111, 0, 0],
        "69": [0, 0.61111, 0, 0],
        "70": [0, 0.61111, 0, 0],
        "71": [0, 0.61111, 0, 0],
        "72": [0, 0.61111, 0, 0],
        "73": [0, 0.61111, 0, 0],
        "74": [0, 0.61111, 0, 0],
        "75": [0, 0.61111, 0, 0],
        "76": [0, 0.61111, 0, 0],
        "77": [0, 0.61111, 0, 0],
        "78": [0, 0.61111, 0, 0],
        "79": [0, 0.61111, 0, 0],
        "80": [0, 0.61111, 0, 0],
        "81": [0.13889, 0.61111, 0, 0],
        "82": [0, 0.61111, 0, 0],
        "83": [0, 0.61111, 0, 0],
        "84": [0, 0.61111, 0, 0],
        "85": [0, 0.61111, 0, 0],
        "86": [0, 0.61111, 0, 0],
        "87": [0, 0.61111, 0, 0],
        "88": [0, 0.61111, 0, 0],
        "89": [0, 0.61111, 0, 0],
        "90": [0, 0.61111, 0, 0],
        "91": [0.08333, 0.69444, 0, 0],
        "92": [0.08333, 0.69444, 0, 0],
        "93": [0.08333, 0.69444, 0, 0],
        "94": [0, 0.61111, 0, 0],
        "95": [0.09514, 0, 0, 0],
        "96": [0, 0.61111, 0, 0],
        "97": [0, 0.43056, 0, 0],
        "98": [0, 0.61111, 0, 0],
        "99": [0, 0.43056, 0, 0],
        "100": [0, 0.61111, 0, 0],
        "101": [0, 0.43056, 0, 0],
        "102": [0, 0.61111, 0, 0],
        "103": [0.22222, 0.43056, 0, 0],
        "104": [0, 0.61111, 0, 0],
        "105": [0, 0.61111, 0, 0],
        "106": [0.22222, 0.61111, 0, 0],
        "107": [0, 0.61111, 0, 0],
        "108": [0, 0.61111, 0, 0],
        "109": [0, 0.43056, 0, 0],
        "110": [0, 0.43056, 0, 0],
        "111": [0, 0.43056, 0, 0],
        "112": [0.22222, 0.43056, 0, 0],
        "113": [0.22222, 0.43056, 0, 0],
        "114": [0, 0.43056, 0, 0],
        "115": [0, 0.43056, 0, 0],
        "116": [0, 0.55358, 0, 0],
        "117": [0, 0.43056, 0, 0],
        "118": [0, 0.43056, 0, 0],
        "119": [0, 0.43056, 0, 0],
        "120": [0, 0.43056, 0, 0],
        "121": [0.22222, 0.43056, 0, 0],
        "122": [0, 0.43056, 0, 0],
        "123": [0.08333, 0.69444, 0, 0],
        "124": [0.08333, 0.69444, 0, 0],
        "125": [0.08333, 0.69444, 0, 0],
        "126": [0, 0.61111, 0, 0],
        "127": [0, 0.61111, 0, 0],
        "305": [0, 0.43056, 0, 0],
        "567": [0.22222, 0.43056, 0, 0],
        "768": [0, 0.61111, 0, 0],
        "769": [0, 0.61111, 0, 0],
        "770": [0, 0.61111, 0, 0],
        "771": [0, 0.61111, 0, 0],
        "772": [0, 0.56555, 0, 0],
        "774": [0, 0.61111, 0, 0],
        "776": [0, 0.61111, 0, 0],
        "778": [0, 0.61111, 0, 0],
        "780": [0, 0.56597, 0, 0],
        "915": [0, 0.61111, 0, 0],
        "916": [0, 0.61111, 0, 0],
        "920": [0, 0.61111, 0, 0],
        "923": [0, 0.61111, 0, 0],
        "926": [0, 0.61111, 0, 0],
        "928": [0, 0.61111, 0, 0],
        "931": [0, 0.61111, 0, 0],
        "933": [0, 0.61111, 0, 0],
        "934": [0, 0.61111, 0, 0],
        "936": [0, 0.61111, 0, 0],
        "937": [0, 0.61111, 0, 0],
        "2018": [0, 0.61111, 0, 0],
        "2019": [0, 0.61111, 0, 0],
        "8242": [0, 0.61111, 0, 0]
      }
    };
  }
});

// node_modules/katex/src/fontMetrics.js
var require_fontMetrics = __commonJS({
  "node_modules/katex/src/fontMetrics.js"(exports, module) {
    var Style = require_Style();
    var sigma5 = 0.431;
    var sigma6 = 1;
    var sigma8 = 0.677;
    var sigma9 = 0.394;
    var sigma10 = 0.444;
    var sigma11 = 0.686;
    var sigma12 = 0.345;
    var sigma13 = 0.413;
    var sigma14 = 0.363;
    var sigma15 = 0.289;
    var sigma16 = 0.15;
    var sigma17 = 0.247;
    var sigma18 = 0.386;
    var sigma19 = 0.05;
    var sigma20 = 2.39;
    var sigma21 = 1.01;
    var sigma21Script = 0.81;
    var sigma21ScriptScript = 0.71;
    var sigma22 = 0.25;
    var xi8 = 0.04;
    var xi9 = 0.111;
    var xi10 = 0.166;
    var xi11 = 0.2;
    var xi12 = 0.6;
    var xi13 = 0.1;
    var ptPerEm = 10;
    var doubleRuleSep = 2 / ptPerEm;
    var metrics = {
      xHeight: sigma5,
      quad: sigma6,
      num1: sigma8,
      num2: sigma9,
      num3: sigma10,
      denom1: sigma11,
      denom2: sigma12,
      sup1: sigma13,
      sup2: sigma14,
      sup3: sigma15,
      sub1: sigma16,
      sub2: sigma17,
      supDrop: sigma18,
      subDrop: sigma19,
      axisHeight: sigma22,
      defaultRuleThickness: xi8,
      bigOpSpacing1: xi9,
      bigOpSpacing2: xi10,
      bigOpSpacing3: xi11,
      bigOpSpacing4: xi12,
      bigOpSpacing5: xi13,
      ptPerEm,
      emPerEx: sigma5 / sigma6,
      doubleRuleSep,
      // TODO(alpert): Missing parallel structure here. We should probably add
      // style-specific metrics for all of these.
      delim1: sigma20,
      getDelim2: function(style) {
        if (style.size === Style.TEXT.size) {
          return sigma21;
        } else if (style.size === Style.SCRIPT.size) {
          return sigma21Script;
        } else if (style.size === Style.SCRIPTSCRIPT.size) {
          return sigma21ScriptScript;
        }
        throw new Error("Unexpected style size: " + style.size);
      }
    };
    var metricMap = require_fontMetricsData();
    var getCharacterMetrics = function(character, style) {
      var metrics2 = metricMap[style][character.charCodeAt(0)];
      if (metrics2) {
        return {
          depth: metrics2[0],
          height: metrics2[1],
          italic: metrics2[2],
          skew: metrics2[3],
          width: metrics2[4]
        };
      }
    };
    module.exports = {
      metrics,
      getCharacterMetrics
    };
  }
});

// node_modules/katex/src/symbols.js
var require_symbols = __commonJS({
  "node_modules/katex/src/symbols.js"(exports, module) {
    module.exports = {
      math: {},
      text: {}
    };
    function defineSymbol(mode, font, group, replace, name) {
      module.exports[mode][name] = {
        font,
        group,
        replace
      };
    }
    var math = "math";
    var text = "text";
    var main = "main";
    var ams = "ams";
    var accent = "accent";
    var bin = "bin";
    var close = "close";
    var inner = "inner";
    var mathord = "mathord";
    var op = "op";
    var open = "open";
    var punct = "punct";
    var rel = "rel";
    var spacing = "spacing";
    var textord = "textord";
    defineSymbol(math, main, rel, "â¡", "\\equiv");
    defineSymbol(math, main, rel, "âº", "\\prec");
    defineSymbol(math, main, rel, "â»", "\\succ");
    defineSymbol(math, main, rel, "â¼", "\\sim");
    defineSymbol(math, main, rel, "â¥", "\\perp");
    defineSymbol(math, main, rel, "âª¯", "\\preceq");
    defineSymbol(math, main, rel, "âª°", "\\succeq");
    defineSymbol(math, main, rel, "â", "\\simeq");
    defineSymbol(math, main, rel, "â£", "\\mid");
    defineSymbol(math, main, rel, "âª", "\\ll");
    defineSymbol(math, main, rel, "â«", "\\gg");
    defineSymbol(math, main, rel, "â", "\\asymp");
    defineSymbol(math, main, rel, "â¥", "\\parallel");
    defineSymbol(math, main, rel, "â", "\\bowtie");
    defineSymbol(math, main, rel, "â£", "\\smile");
    defineSymbol(math, main, rel, "â", "\\sqsubseteq");
    defineSymbol(math, main, rel, "â", "\\sqsupseteq");
    defineSymbol(math, main, rel, "â", "\\doteq");
    defineSymbol(math, main, rel, "â¢", "\\frown");
    defineSymbol(math, main, rel, "â", "\\ni");
    defineSymbol(math, main, rel, "â", "\\propto");
    defineSymbol(math, main, rel, "â¢", "\\vdash");
    defineSymbol(math, main, rel, "â£", "\\dashv");
    defineSymbol(math, main, rel, "â", "\\owns");
    defineSymbol(math, main, punct, ".", "\\ldotp");
    defineSymbol(math, main, punct, "â", "\\cdotp");
    defineSymbol(math, main, textord, "#", "\\#");
    defineSymbol(math, main, textord, "&", "\\&");
    defineSymbol(math, main, textord, "âµ", "\\aleph");
    defineSymbol(math, main, textord, "â", "\\forall");
    defineSymbol(math, main, textord, "â", "\\hbar");
    defineSymbol(math, main, textord, "â", "\\exists");
    defineSymbol(math, main, textord, "â", "\\nabla");
    defineSymbol(math, main, textord, "â­", "\\flat");
    defineSymbol(math, main, textord, "â", "\\ell");
    defineSymbol(math, main, textord, "â®", "\\natural");
    defineSymbol(math, main, textord, "â£", "\\clubsuit");
    defineSymbol(math, main, textord, "â", "\\wp");
    defineSymbol(math, main, textord, "â¯", "\\sharp");
    defineSymbol(math, main, textord, "â¢", "\\diamondsuit");
    defineSymbol(math, main, textord, "â", "\\Re");
    defineSymbol(math, main, textord, "â¡", "\\heartsuit");
    defineSymbol(math, main, textord, "â", "\\Im");
    defineSymbol(math, main, textord, "â ", "\\spadesuit");
    defineSymbol(math, main, textord, "â ", "\\dag");
    defineSymbol(math, main, textord, "â¡", "\\ddag");
    defineSymbol(math, main, close, "â±", "\\rmoustache");
    defineSymbol(math, main, open, "â°", "\\lmoustache");
    defineSymbol(math, main, close, "â¯", "\\rgroup");
    defineSymbol(math, main, open, "â®", "\\lgroup");
    defineSymbol(math, main, bin, "â", "\\mp");
    defineSymbol(math, main, bin, "â", "\\ominus");
    defineSymbol(math, main, bin, "â", "\\uplus");
    defineSymbol(math, main, bin, "â", "\\sqcap");
    defineSymbol(math, main, bin, "â", "\\ast");
    defineSymbol(math, main, bin, "â", "\\sqcup");
    defineSymbol(math, main, bin, "â¯", "\\bigcirc");
    defineSymbol(math, main, bin, "â", "\\bullet");
    defineSymbol(math, main, bin, "â¡", "\\ddagger");
    defineSymbol(math, main, bin, "â", "\\wr");
    defineSymbol(math, main, bin, "â¨¿", "\\amalg");
    defineSymbol(math, main, rel, "âµ", "\\longleftarrow");
    defineSymbol(math, main, rel, "â", "\\Leftarrow");
    defineSymbol(math, main, rel, "â¸", "\\Longleftarrow");
    defineSymbol(math, main, rel, "â¶", "\\longrightarrow");
    defineSymbol(math, main, rel, "â", "\\Rightarrow");
    defineSymbol(math, main, rel, "â¹", "\\Longrightarrow");
    defineSymbol(math, main, rel, "â", "\\leftrightarrow");
    defineSymbol(math, main, rel, "â·", "\\longleftrightarrow");
    defineSymbol(math, main, rel, "â", "\\Leftrightarrow");
    defineSymbol(math, main, rel, "âº", "\\Longleftrightarrow");
    defineSymbol(math, main, rel, "â¦", "\\mapsto");
    defineSymbol(math, main, rel, "â¼", "\\longmapsto");
    defineSymbol(math, main, rel, "â", "\\nearrow");
    defineSymbol(math, main, rel, "â©", "\\hookleftarrow");
    defineSymbol(math, main, rel, "âª", "\\hookrightarrow");
    defineSymbol(math, main, rel, "â", "\\searrow");
    defineSymbol(math, main, rel, "â¼", "\\leftharpoonup");
    defineSymbol(math, main, rel, "â", "\\rightharpoonup");
    defineSymbol(math, main, rel, "â", "\\swarrow");
    defineSymbol(math, main, rel, "â½", "\\leftharpoondown");
    defineSymbol(math, main, rel, "â", "\\rightharpoondown");
    defineSymbol(math, main, rel, "â", "\\nwarrow");
    defineSymbol(math, main, rel, "â", "\\rightleftharpoons");
    defineSymbol(math, ams, rel, "â®", "\\nless");
    defineSymbol(math, ams, rel, "î", "\\nleqslant");
    defineSymbol(math, ams, rel, "î", "\\nleqq");
    defineSymbol(math, ams, rel, "âª", "\\lneq");
    defineSymbol(math, ams, rel, "â¨", "\\lneqq");
    defineSymbol(math, ams, rel, "î", "\\lvertneqq");
    defineSymbol(math, ams, rel, "â¦", "\\lnsim");
    defineSymbol(math, ams, rel, "âª", "\\lnapprox");
    defineSymbol(math, ams, rel, "â", "\\nprec");
    defineSymbol(math, ams, rel, "â ", "\\npreceq");
    defineSymbol(math, ams, rel, "â¨", "\\precnsim");
    defineSymbol(math, ams, rel, "âª¹", "\\precnapprox");
    defineSymbol(math, ams, rel, "â", "\\nsim");
    defineSymbol(math, ams, rel, "î", "\\nshortmid");
    defineSymbol(math, ams, rel, "â¤", "\\nmid");
    defineSymbol(math, ams, rel, "â¬", "\\nvdash");
    defineSymbol(math, ams, rel, "â­", "\\nvDash");
    defineSymbol(math, ams, rel, "âª", "\\ntriangleleft");
    defineSymbol(math, ams, rel, "â¬", "\\ntrianglelefteq");
    defineSymbol(math, ams, rel, "â", "\\subsetneq");
    defineSymbol(math, ams, rel, "î", "\\varsubsetneq");
    defineSymbol(math, ams, rel, "â«", "\\subsetneqq");
    defineSymbol(math, ams, rel, "î", "\\varsubsetneqq");
    defineSymbol(math, ams, rel, "â¯", "\\ngtr");
    defineSymbol(math, ams, rel, "î", "\\ngeqslant");
    defineSymbol(math, ams, rel, "î", "\\ngeqq");
    defineSymbol(math, ams, rel, "âª", "\\gneq");
    defineSymbol(math, ams, rel, "â©", "\\gneqq");
    defineSymbol(math, ams, rel, "î", "\\gvertneqq");
    defineSymbol(math, ams, rel, "â§", "\\gnsim");
    defineSymbol(math, ams, rel, "âª", "\\gnapprox");
    defineSymbol(math, ams, rel, "â", "\\nsucc");
    defineSymbol(math, ams, rel, "â¡", "\\nsucceq");
    defineSymbol(math, ams, rel, "â©", "\\succnsim");
    defineSymbol(math, ams, rel, "âªº", "\\succnapprox");
    defineSymbol(math, ams, rel, "â", "\\ncong");
    defineSymbol(math, ams, rel, "î", "\\nshortparallel");
    defineSymbol(math, ams, rel, "â¦", "\\nparallel");
    defineSymbol(math, ams, rel, "â¯", "\\nVDash");
    defineSymbol(math, ams, rel, "â«", "\\ntriangleright");
    defineSymbol(math, ams, rel, "â­", "\\ntrianglerighteq");
    defineSymbol(math, ams, rel, "î", "\\nsupseteqq");
    defineSymbol(math, ams, rel, "â", "\\supsetneq");
    defineSymbol(math, ams, rel, "î", "\\varsupsetneq");
    defineSymbol(math, ams, rel, "â«", "\\supsetneqq");
    defineSymbol(math, ams, rel, "î", "\\varsupsetneqq");
    defineSymbol(math, ams, rel, "â®", "\\nVdash");
    defineSymbol(math, ams, rel, "âªµ", "\\precneqq");
    defineSymbol(math, ams, rel, "âª¶", "\\succneqq");
    defineSymbol(math, ams, rel, "î", "\\nsubseteqq");
    defineSymbol(math, ams, bin, "â´", "\\unlhd");
    defineSymbol(math, ams, bin, "âµ", "\\unrhd");
    defineSymbol(math, ams, rel, "â", "\\nleftarrow");
    defineSymbol(math, ams, rel, "â", "\\nrightarrow");
    defineSymbol(math, ams, rel, "â", "\\nLeftarrow");
    defineSymbol(math, ams, rel, "â", "\\nRightarrow");
    defineSymbol(math, ams, rel, "â®", "\\nleftrightarrow");
    defineSymbol(math, ams, rel, "â", "\\nLeftrightarrow");
    defineSymbol(math, ams, rel, "â³", "\\vartriangle");
    defineSymbol(math, ams, textord, "â", "\\hslash");
    defineSymbol(math, ams, textord, "â½", "\\triangledown");
    defineSymbol(math, ams, textord, "â", "\\lozenge");
    defineSymbol(math, ams, textord, "â", "\\circledS");
    defineSymbol(math, ams, textord, "Â®", "\\circledR");
    defineSymbol(math, ams, textord, "â¡", "\\measuredangle");
    defineSymbol(math, ams, textord, "â", "\\nexists");
    defineSymbol(math, ams, textord, "â§", "\\mho");
    defineSymbol(math, ams, textord, "â²", "\\Finv");
    defineSymbol(math, ams, textord, "â", "\\Game");
    defineSymbol(math, ams, textord, "k", "\\Bbbk");
    defineSymbol(math, ams, textord, "âµ", "\\backprime");
    defineSymbol(math, ams, textord, "â²", "\\blacktriangle");
    defineSymbol(math, ams, textord, "â¼", "\\blacktriangledown");
    defineSymbol(math, ams, textord, "â ", "\\blacksquare");
    defineSymbol(math, ams, textord, "â§«", "\\blacklozenge");
    defineSymbol(math, ams, textord, "â", "\\bigstar");
    defineSymbol(math, ams, textord, "â¢", "\\sphericalangle");
    defineSymbol(math, ams, textord, "â", "\\complement");
    defineSymbol(math, ams, textord, "Ã°", "\\eth");
    defineSymbol(math, ams, textord, "â±", "\\diagup");
    defineSymbol(math, ams, textord, "â²", "\\diagdown");
    defineSymbol(math, ams, textord, "â¡", "\\square");
    defineSymbol(math, ams, textord, "â¡", "\\Box");
    defineSymbol(math, ams, textord, "â", "\\Diamond");
    defineSymbol(math, ams, textord, "Â¥", "\\yen");
    defineSymbol(math, ams, textord, "â", "\\checkmark");
    defineSymbol(math, ams, textord, "â¶", "\\beth");
    defineSymbol(math, ams, textord, "â¸", "\\daleth");
    defineSymbol(math, ams, textord, "â·", "\\gimel");
    defineSymbol(math, ams, textord, "Ï", "\\digamma");
    defineSymbol(math, ams, textord, "Ï°", "\\varkappa");
    defineSymbol(math, ams, open, "â", "\\ulcorner");
    defineSymbol(math, ams, close, "â", "\\urcorner");
    defineSymbol(math, ams, open, "â", "\\llcorner");
    defineSymbol(math, ams, close, "â", "\\lrcorner");
    defineSymbol(math, ams, rel, "â¦", "\\leqq");
    defineSymbol(math, ams, rel, "â©½", "\\leqslant");
    defineSymbol(math, ams, rel, "âª", "\\eqslantless");
    defineSymbol(math, ams, rel, "â²", "\\lesssim");
    defineSymbol(math, ams, rel, "âª", "\\lessapprox");
    defineSymbol(math, ams, rel, "â", "\\approxeq");
    defineSymbol(math, ams, bin, "â", "\\lessdot");
    defineSymbol(math, ams, rel, "â", "\\lll");
    defineSymbol(math, ams, rel, "â¶", "\\lessgtr");
    defineSymbol(math, ams, rel, "â", "\\lesseqgtr");
    defineSymbol(math, ams, rel, "âª", "\\lesseqqgtr");
    defineSymbol(math, ams, rel, "â", "\\doteqdot");
    defineSymbol(math, ams, rel, "â", "\\risingdotseq");
    defineSymbol(math, ams, rel, "â", "\\fallingdotseq");
    defineSymbol(math, ams, rel, "â½", "\\backsim");
    defineSymbol(math, ams, rel, "â", "\\backsimeq");
    defineSymbol(math, ams, rel, "â«", "\\subseteqq");
    defineSymbol(math, ams, rel, "â", "\\Subset");
    defineSymbol(math, ams, rel, "â", "\\sqsubset");
    defineSymbol(math, ams, rel, "â¼", "\\preccurlyeq");
    defineSymbol(math, ams, rel, "â", "\\curlyeqprec");
    defineSymbol(math, ams, rel, "â¾", "\\precsim");
    defineSymbol(math, ams, rel, "âª·", "\\precapprox");
    defineSymbol(math, ams, rel, "â²", "\\vartriangleleft");
    defineSymbol(math, ams, rel, "â´", "\\trianglelefteq");
    defineSymbol(math, ams, rel, "â¨", "\\vDash");
    defineSymbol(math, ams, rel, "âª", "\\Vvdash");
    defineSymbol(math, ams, rel, "â£", "\\smallsmile");
    defineSymbol(math, ams, rel, "â¢", "\\smallfrown");
    defineSymbol(math, ams, rel, "â", "\\bumpeq");
    defineSymbol(math, ams, rel, "â", "\\Bumpeq");
    defineSymbol(math, ams, rel, "â§", "\\geqq");
    defineSymbol(math, ams, rel, "â©¾", "\\geqslant");
    defineSymbol(math, ams, rel, "âª", "\\eqslantgtr");
    defineSymbol(math, ams, rel, "â³", "\\gtrsim");
    defineSymbol(math, ams, rel, "âª", "\\gtrapprox");
    defineSymbol(math, ams, bin, "â", "\\gtrdot");
    defineSymbol(math, ams, rel, "â", "\\ggg");
    defineSymbol(math, ams, rel, "â·", "\\gtrless");
    defineSymbol(math, ams, rel, "â", "\\gtreqless");
    defineSymbol(math, ams, rel, "âª", "\\gtreqqless");
    defineSymbol(math, ams, rel, "â", "\\eqcirc");
    defineSymbol(math, ams, rel, "â", "\\circeq");
    defineSymbol(math, ams, rel, "â", "\\triangleq");
    defineSymbol(math, ams, rel, "â¼", "\\thicksim");
    defineSymbol(math, ams, rel, "â", "\\thickapprox");
    defineSymbol(math, ams, rel, "â«", "\\supseteqq");
    defineSymbol(math, ams, rel, "â", "\\Supset");
    defineSymbol(math, ams, rel, "â", "\\sqsupset");
    defineSymbol(math, ams, rel, "â½", "\\succcurlyeq");
    defineSymbol(math, ams, rel, "â", "\\curlyeqsucc");
    defineSymbol(math, ams, rel, "â¿", "\\succsim");
    defineSymbol(math, ams, rel, "âª¸", "\\succapprox");
    defineSymbol(math, ams, rel, "â³", "\\vartriangleright");
    defineSymbol(math, ams, rel, "âµ", "\\trianglerighteq");
    defineSymbol(math, ams, rel, "â©", "\\Vdash");
    defineSymbol(math, ams, rel, "â£", "\\shortmid");
    defineSymbol(math, ams, rel, "â¥", "\\shortparallel");
    defineSymbol(math, ams, rel, "â¬", "\\between");
    defineSymbol(math, ams, rel, "â", "\\pitchfork");
    defineSymbol(math, ams, rel, "â", "\\varpropto");
    defineSymbol(math, ams, rel, "â", "\\blacktriangleleft");
    defineSymbol(math, ams, rel, "â´", "\\therefore");
    defineSymbol(math, ams, rel, "â", "\\backepsilon");
    defineSymbol(math, ams, rel, "â¶", "\\blacktriangleright");
    defineSymbol(math, ams, rel, "âµ", "\\because");
    defineSymbol(math, ams, rel, "â", "\\llless");
    defineSymbol(math, ams, rel, "â", "\\gggtr");
    defineSymbol(math, ams, bin, "â²", "\\lhd");
    defineSymbol(math, ams, bin, "â³", "\\rhd");
    defineSymbol(math, ams, rel, "â", "\\eqsim");
    defineSymbol(math, main, rel, "â", "\\Join");
    defineSymbol(math, ams, rel, "â", "\\Doteq");
    defineSymbol(math, ams, bin, "â", "\\dotplus");
    defineSymbol(math, ams, bin, "â", "\\smallsetminus");
    defineSymbol(math, ams, bin, "â", "\\Cap");
    defineSymbol(math, ams, bin, "â", "\\Cup");
    defineSymbol(math, ams, bin, "â©", "\\doublebarwedge");
    defineSymbol(math, ams, bin, "â", "\\boxminus");
    defineSymbol(math, ams, bin, "â", "\\boxplus");
    defineSymbol(math, ams, bin, "â", "\\divideontimes");
    defineSymbol(math, ams, bin, "â", "\\ltimes");
    defineSymbol(math, ams, bin, "â", "\\rtimes");
    defineSymbol(math, ams, bin, "â", "\\leftthreetimes");
    defineSymbol(math, ams, bin, "â", "\\rightthreetimes");
    defineSymbol(math, ams, bin, "â", "\\curlywedge");
    defineSymbol(math, ams, bin, "â", "\\curlyvee");
    defineSymbol(math, ams, bin, "â", "\\circleddash");
    defineSymbol(math, ams, bin, "â", "\\circledast");
    defineSymbol(math, ams, bin, "â", "\\centerdot");
    defineSymbol(math, ams, bin, "âº", "\\intercal");
    defineSymbol(math, ams, bin, "â", "\\doublecap");
    defineSymbol(math, ams, bin, "â", "\\doublecup");
    defineSymbol(math, ams, bin, "â ", "\\boxtimes");
    defineSymbol(math, ams, rel, "â¢", "\\dashrightarrow");
    defineSymbol(math, ams, rel, "â ", "\\dashleftarrow");
    defineSymbol(math, ams, rel, "â", "\\leftleftarrows");
    defineSymbol(math, ams, rel, "â", "\\leftrightarrows");
    defineSymbol(math, ams, rel, "â", "\\Lleftarrow");
    defineSymbol(math, ams, rel, "â", "\\twoheadleftarrow");
    defineSymbol(math, ams, rel, "â¢", "\\leftarrowtail");
    defineSymbol(math, ams, rel, "â«", "\\looparrowleft");
    defineSymbol(math, ams, rel, "â", "\\leftrightharpoons");
    defineSymbol(math, ams, rel, "â¶", "\\curvearrowleft");
    defineSymbol(math, ams, rel, "âº", "\\circlearrowleft");
    defineSymbol(math, ams, rel, "â°", "\\Lsh");
    defineSymbol(math, ams, rel, "â", "\\upuparrows");
    defineSymbol(math, ams, rel, "â¿", "\\upharpoonleft");
    defineSymbol(math, ams, rel, "â", "\\downharpoonleft");
    defineSymbol(math, ams, rel, "â¸", "\\multimap");
    defineSymbol(math, ams, rel, "â­", "\\leftrightsquigarrow");
    defineSymbol(math, ams, rel, "â", "\\rightrightarrows");
    defineSymbol(math, ams, rel, "â", "\\rightleftarrows");
    defineSymbol(math, ams, rel, "â ", "\\twoheadrightarrow");
    defineSymbol(math, ams, rel, "â£", "\\rightarrowtail");
    defineSymbol(math, ams, rel, "â¬", "\\looparrowright");
    defineSymbol(math, ams, rel, "â·", "\\curvearrowright");
    defineSymbol(math, ams, rel, "â»", "\\circlearrowright");
    defineSymbol(math, ams, rel, "â±", "\\Rsh");
    defineSymbol(math, ams, rel, "â", "\\downdownarrows");
    defineSymbol(math, ams, rel, "â¾", "\\upharpoonright");
    defineSymbol(math, ams, rel, "â", "\\downharpoonright");
    defineSymbol(math, ams, rel, "â", "\\rightsquigarrow");
    defineSymbol(math, ams, rel, "â", "\\leadsto");
    defineSymbol(math, ams, rel, "â", "\\Rrightarrow");
    defineSymbol(math, ams, rel, "â¾", "\\restriction");
    defineSymbol(math, main, textord, "â", "`");
    defineSymbol(math, main, textord, "$", "\\$");
    defineSymbol(math, main, textord, "%", "\\%");
    defineSymbol(math, main, textord, "_", "\\_");
    defineSymbol(math, main, textord, "â ", "\\angle");
    defineSymbol(math, main, textord, "â", "\\infty");
    defineSymbol(math, main, textord, "â²", "\\prime");
    defineSymbol(math, main, textord, "â³", "\\triangle");
    defineSymbol(math, main, textord, "Î", "\\Gamma");
    defineSymbol(math, main, textord, "Î", "\\Delta");
    defineSymbol(math, main, textord, "Î", "\\Theta");
    defineSymbol(math, main, textord, "Î", "\\Lambda");
    defineSymbol(math, main, textord, "Î", "\\Xi");
    defineSymbol(math, main, textord, "Î ", "\\Pi");
    defineSymbol(math, main, textord, "Î£", "\\Sigma");
    defineSymbol(math, main, textord, "Î¥", "\\Upsilon");
    defineSymbol(math, main, textord, "Î¦", "\\Phi");
    defineSymbol(math, main, textord, "Î¨", "\\Psi");
    defineSymbol(math, main, textord, "Î©", "\\Omega");
    defineSymbol(math, main, textord, "Â¬", "\\neg");
    defineSymbol(math, main, textord, "Â¬", "\\lnot");
    defineSymbol(math, main, textord, "â¤", "\\top");
    defineSymbol(math, main, textord, "â¥", "\\bot");
    defineSymbol(math, main, textord, "â", "\\emptyset");
    defineSymbol(math, ams, textord, "â", "\\varnothing");
    defineSymbol(math, main, mathord, "Î±", "\\alpha");
    defineSymbol(math, main, mathord, "Î²", "\\beta");
    defineSymbol(math, main, mathord, "Î³", "\\gamma");
    defineSymbol(math, main, mathord, "Î´", "\\delta");
    defineSymbol(math, main, mathord, "Ïµ", "\\epsilon");
    defineSymbol(math, main, mathord, "Î¶", "\\zeta");
    defineSymbol(math, main, mathord, "Î·", "\\eta");
    defineSymbol(math, main, mathord, "Î¸", "\\theta");
    defineSymbol(math, main, mathord, "Î¹", "\\iota");
    defineSymbol(math, main, mathord, "Îº", "\\kappa");
    defineSymbol(math, main, mathord, "Î»", "\\lambda");
    defineSymbol(math, main, mathord, "Î¼", "\\mu");
    defineSymbol(math, main, mathord, "Î½", "\\nu");
    defineSymbol(math, main, mathord, "Î¾", "\\xi");
    defineSymbol(math, main, mathord, "o", "\\omicron");
    defineSymbol(math, main, mathord, "Ï", "\\pi");
    defineSymbol(math, main, mathord, "Ï", "\\rho");
    defineSymbol(math, main, mathord, "Ï", "\\sigma");
    defineSymbol(math, main, mathord, "Ï", "\\tau");
    defineSymbol(math, main, mathord, "Ï", "\\upsilon");
    defineSymbol(math, main, mathord, "Ï", "\\phi");
    defineSymbol(math, main, mathord, "Ï", "\\chi");
    defineSymbol(math, main, mathord, "Ï", "\\psi");
    defineSymbol(math, main, mathord, "Ï", "\\omega");
    defineSymbol(math, main, mathord, "Îµ", "\\varepsilon");
    defineSymbol(math, main, mathord, "Ï", "\\vartheta");
    defineSymbol(math, main, mathord, "Ï", "\\varpi");
    defineSymbol(math, main, mathord, "Ï±", "\\varrho");
    defineSymbol(math, main, mathord, "Ï", "\\varsigma");
    defineSymbol(math, main, mathord, "Ï", "\\varphi");
    defineSymbol(math, main, bin, "â", "*");
    defineSymbol(math, main, bin, "+", "+");
    defineSymbol(math, main, bin, "â", "-");
    defineSymbol(math, main, bin, "â", "\\cdot");
    defineSymbol(math, main, bin, "â", "\\circ");
    defineSymbol(math, main, bin, "Ã·", "\\div");
    defineSymbol(math, main, bin, "Â±", "\\pm");
    defineSymbol(math, main, bin, "Ã", "\\times");
    defineSymbol(math, main, bin, "â©", "\\cap");
    defineSymbol(math, main, bin, "âª", "\\cup");
    defineSymbol(math, main, bin, "â", "\\setminus");
    defineSymbol(math, main, bin, "â§", "\\land");
    defineSymbol(math, main, bin, "â¨", "\\lor");
    defineSymbol(math, main, bin, "â§", "\\wedge");
    defineSymbol(math, main, bin, "â¨", "\\vee");
    defineSymbol(math, main, textord, "â", "\\surd");
    defineSymbol(math, main, open, "(", "(");
    defineSymbol(math, main, open, "[", "[");
    defineSymbol(math, main, open, "â¨", "\\langle");
    defineSymbol(math, main, open, "â£", "\\lvert");
    defineSymbol(math, main, open, "â¥", "\\lVert");
    defineSymbol(math, main, close, ")", ")");
    defineSymbol(math, main, close, "]", "]");
    defineSymbol(math, main, close, "?", "?");
    defineSymbol(math, main, close, "!", "!");
    defineSymbol(math, main, close, "â©", "\\rangle");
    defineSymbol(math, main, close, "â£", "\\rvert");
    defineSymbol(math, main, close, "â¥", "\\rVert");
    defineSymbol(math, main, rel, "=", "=");
    defineSymbol(math, main, rel, "<", "<");
    defineSymbol(math, main, rel, ">", ">");
    defineSymbol(math, main, rel, ":", ":");
    defineSymbol(math, main, rel, "â", "\\approx");
    defineSymbol(math, main, rel, "â", "\\cong");
    defineSymbol(math, main, rel, "â¥", "\\ge");
    defineSymbol(math, main, rel, "â¥", "\\geq");
    defineSymbol(math, main, rel, "â", "\\gets");
    defineSymbol(math, main, rel, ">", "\\gt");
    defineSymbol(math, main, rel, "â", "\\in");
    defineSymbol(math, main, rel, "â", "\\notin");
    defineSymbol(math, main, rel, "â", "\\subset");
    defineSymbol(math, main, rel, "â", "\\supset");
    defineSymbol(math, main, rel, "â", "\\subseteq");
    defineSymbol(math, main, rel, "â", "\\supseteq");
    defineSymbol(math, ams, rel, "â", "\\nsubseteq");
    defineSymbol(math, ams, rel, "â", "\\nsupseteq");
    defineSymbol(math, main, rel, "â¨", "\\models");
    defineSymbol(math, main, rel, "â", "\\leftarrow");
    defineSymbol(math, main, rel, "â¤", "\\le");
    defineSymbol(math, main, rel, "â¤", "\\leq");
    defineSymbol(math, main, rel, "<", "\\lt");
    defineSymbol(math, main, rel, "â ", "\\ne");
    defineSymbol(math, main, rel, "â ", "\\neq");
    defineSymbol(math, main, rel, "â", "\\rightarrow");
    defineSymbol(math, main, rel, "â", "\\to");
    defineSymbol(math, ams, rel, "â±", "\\ngeq");
    defineSymbol(math, ams, rel, "â°", "\\nleq");
    defineSymbol(math, main, spacing, null, "\\!");
    defineSymbol(math, main, spacing, "Â ", "\\ ");
    defineSymbol(math, main, spacing, "Â ", "~");
    defineSymbol(math, main, spacing, null, "\\,");
    defineSymbol(math, main, spacing, null, "\\:");
    defineSymbol(math, main, spacing, null, "\\;");
    defineSymbol(math, main, spacing, null, "\\enspace");
    defineSymbol(math, main, spacing, null, "\\qquad");
    defineSymbol(math, main, spacing, null, "\\quad");
    defineSymbol(math, main, spacing, "Â ", "\\space");
    defineSymbol(math, main, punct, ",", ",");
    defineSymbol(math, main, punct, ";", ";");
    defineSymbol(math, main, punct, ":", "\\colon");
    defineSymbol(math, ams, bin, "â¼", "\\barwedge");
    defineSymbol(math, ams, bin, "â»", "\\veebar");
    defineSymbol(math, main, bin, "â", "\\odot");
    defineSymbol(math, main, bin, "â", "\\oplus");
    defineSymbol(math, main, bin, "â", "\\otimes");
    defineSymbol(math, main, textord, "â", "\\partial");
    defineSymbol(math, main, bin, "â", "\\oslash");
    defineSymbol(math, ams, bin, "â", "\\circledcirc");
    defineSymbol(math, ams, bin, "â¡", "\\boxdot");
    defineSymbol(math, main, bin, "â³", "\\bigtriangleup");
    defineSymbol(math, main, bin, "â½", "\\bigtriangledown");
    defineSymbol(math, main, bin, "â ", "\\dagger");
    defineSymbol(math, main, bin, "â", "\\diamond");
    defineSymbol(math, main, bin, "â", "\\star");
    defineSymbol(math, main, bin, "â", "\\triangleleft");
    defineSymbol(math, main, bin, "â¹", "\\triangleright");
    defineSymbol(math, main, open, "{", "\\{");
    defineSymbol(math, main, close, "}", "\\}");
    defineSymbol(math, main, open, "{", "\\lbrace");
    defineSymbol(math, main, close, "}", "\\rbrace");
    defineSymbol(math, main, open, "[", "\\lbrack");
    defineSymbol(math, main, close, "]", "\\rbrack");
    defineSymbol(math, main, open, "â", "\\lfloor");
    defineSymbol(math, main, close, "â", "\\rfloor");
    defineSymbol(math, main, open, "â", "\\lceil");
    defineSymbol(math, main, close, "â", "\\rceil");
    defineSymbol(math, main, textord, "\\", "\\backslash");
    defineSymbol(math, main, textord, "â£", "|");
    defineSymbol(math, main, textord, "â£", "\\vert");
    defineSymbol(math, main, textord, "â¥", "\\|");
    defineSymbol(math, main, textord, "â¥", "\\Vert");
    defineSymbol(math, main, rel, "â", "\\uparrow");
    defineSymbol(math, main, rel, "â", "\\Uparrow");
    defineSymbol(math, main, rel, "â", "\\downarrow");
    defineSymbol(math, main, rel, "â", "\\Downarrow");
    defineSymbol(math, main, rel, "â", "\\updownarrow");
    defineSymbol(math, main, rel, "â", "\\Updownarrow");
    defineSymbol(math, math, op, "â", "\\coprod");
    defineSymbol(math, math, op, "â", "\\bigvee");
    defineSymbol(math, math, op, "â", "\\bigwedge");
    defineSymbol(math, math, op, "â¨", "\\biguplus");
    defineSymbol(math, math, op, "â", "\\bigcap");
    defineSymbol(math, math, op, "â", "\\bigcup");
    defineSymbol(math, math, op, "â«", "\\int");
    defineSymbol(math, math, op, "â«", "\\intop");
    defineSymbol(math, math, op, "â¬", "\\iint");
    defineSymbol(math, math, op, "â­", "\\iiint");
    defineSymbol(math, math, op, "â", "\\prod");
    defineSymbol(math, math, op, "â", "\\sum");
    defineSymbol(math, math, op, "â¨", "\\bigotimes");
    defineSymbol(math, math, op, "â¨", "\\bigoplus");
    defineSymbol(math, math, op, "â¨", "\\bigodot");
    defineSymbol(math, math, op, "â®", "\\oint");
    defineSymbol(math, math, op, "â¨", "\\bigsqcup");
    defineSymbol(math, math, op, "â«", "\\smallint");
    defineSymbol(math, main, inner, "â¦", "\\ldots");
    defineSymbol(math, main, inner, "â¯", "\\cdots");
    defineSymbol(math, main, inner, "â±", "\\ddots");
    defineSymbol(math, main, textord, "â®", "\\vdots");
    defineSymbol(math, main, accent, "Â´", "\\acute");
    defineSymbol(math, main, accent, "`", "\\grave");
    defineSymbol(math, main, accent, "Â¨", "\\ddot");
    defineSymbol(math, main, accent, "~", "\\tilde");
    defineSymbol(math, main, accent, "Â¯", "\\bar");
    defineSymbol(math, main, accent, "Ë", "\\breve");
    defineSymbol(math, main, accent, "Ë", "\\check");
    defineSymbol(math, main, accent, "^", "\\hat");
    defineSymbol(math, main, accent, "â", "\\vec");
    defineSymbol(math, main, accent, "Ë", "\\dot");
    defineSymbol(math, main, mathord, "Ä±", "\\imath");
    defineSymbol(math, main, mathord, "È·", "\\jmath");
    defineSymbol(text, main, spacing, "Â ", "\\ ");
    defineSymbol(text, main, spacing, "Â ", " ");
    defineSymbol(text, main, spacing, "Â ", "~");
    var i;
    var ch;
    var mathTextSymbols = '0123456789/@."';
    for (i = 0; i < mathTextSymbols.length; i++) {
      ch = mathTextSymbols.charAt(i);
      defineSymbol(math, main, textord, ch, ch);
    }
    var textSymbols = "0123456789`!@*()-=+[]'\";:?/.,";
    for (i = 0; i < textSymbols.length; i++) {
      ch = textSymbols.charAt(i);
      defineSymbol(text, main, textord, ch, ch);
    }
    var letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    for (i = 0; i < letters.length; i++) {
      ch = letters.charAt(i);
      defineSymbol(math, main, mathord, ch, ch);
      defineSymbol(text, main, textord, ch, ch);
    }
  }
});

// node_modules/katex/src/buildCommon.js
var require_buildCommon = __commonJS({
  "node_modules/katex/src/buildCommon.js"(exports, module) {
    var domTree = require_domTree();
    var fontMetrics = require_fontMetrics();
    var symbols = require_symbols();
    var utils = require_utils();
    var greekCapitals = [
      "\\Gamma",
      "\\Delta",
      "\\Theta",
      "\\Lambda",
      "\\Xi",
      "\\Pi",
      "\\Sigma",
      "\\Upsilon",
      "\\Phi",
      "\\Psi",
      "\\Omega"
    ];
    var dotlessLetters = [
      "Ä±",
      // dotless i, \imath
      "È·"
      // dotless j, \jmath
    ];
    var makeSymbol = function(value, style, mode, color, classes) {
      if (symbols[mode][value] && symbols[mode][value].replace) {
        value = symbols[mode][value].replace;
      }
      var metrics = fontMetrics.getCharacterMetrics(value, style);
      var symbolNode;
      if (metrics) {
        symbolNode = new domTree.symbolNode(
          value,
          metrics.height,
          metrics.depth,
          metrics.italic,
          metrics.skew,
          classes
        );
      } else {
        typeof console !== "undefined" && console.warn(
          "No character metrics for '" + value + "' in style '" + style + "'"
        );
        symbolNode = new domTree.symbolNode(value, 0, 0, 0, 0, classes);
      }
      if (color) {
        symbolNode.style.color = color;
      }
      return symbolNode;
    };
    var mathsym = function(value, mode, color, classes) {
      if (value === "\\" || symbols[mode][value].font === "main") {
        return makeSymbol(value, "Main-Regular", mode, color, classes);
      } else {
        return makeSymbol(
          value,
          "AMS-Regular",
          mode,
          color,
          classes.concat(["amsrm"])
        );
      }
    };
    var mathDefault = function(value, mode, color, classes, type) {
      if (type === "mathord") {
        return mathit(value, mode, color, classes);
      } else if (type === "textord") {
        return makeSymbol(
          value,
          "Main-Regular",
          mode,
          color,
          classes.concat(["mathrm"])
        );
      } else {
        throw new Error("unexpected type: " + type + " in mathDefault");
      }
    };
    var mathit = function(value, mode, color, classes) {
      if (/[0-9]/.test(value.charAt(0)) || // glyphs for \imath and \jmath do not exist in Math-Italic so we
      // need to use Main-Italic instead
      utils.contains(dotlessLetters, value) || utils.contains(greekCapitals, value)) {
        return makeSymbol(
          value,
          "Main-Italic",
          mode,
          color,
          classes.concat(["mainit"])
        );
      } else {
        return makeSymbol(
          value,
          "Math-Italic",
          mode,
          color,
          classes.concat(["mathit"])
        );
      }
    };
    var makeOrd = function(group, options, type) {
      var mode = group.mode;
      var value = group.value;
      if (symbols[mode][value] && symbols[mode][value].replace) {
        value = symbols[mode][value].replace;
      }
      var classes = ["mord"];
      var color = options.getColor();
      var font = options.font;
      if (font) {
        if (font === "mathit" || utils.contains(dotlessLetters, value)) {
          return mathit(value, mode, color, classes);
        } else {
          var fontName = fontMap[font].fontName;
          if (fontMetrics.getCharacterMetrics(value, fontName)) {
            return makeSymbol(
              value,
              fontName,
              mode,
              color,
              classes.concat([font])
            );
          } else {
            return mathDefault(value, mode, color, classes, type);
          }
        }
      } else {
        return mathDefault(value, mode, color, classes, type);
      }
    };
    var sizeElementFromChildren = function(elem) {
      var height = 0;
      var depth = 0;
      var maxFontSize = 0;
      if (elem.children) {
        for (var i = 0; i < elem.children.length; i++) {
          if (elem.children[i].height > height) {
            height = elem.children[i].height;
          }
          if (elem.children[i].depth > depth) {
            depth = elem.children[i].depth;
          }
          if (elem.children[i].maxFontSize > maxFontSize) {
            maxFontSize = elem.children[i].maxFontSize;
          }
        }
      }
      elem.height = height;
      elem.depth = depth;
      elem.maxFontSize = maxFontSize;
    };
    var makeSpan = function(classes, children, color) {
      var span = new domTree.span(classes, children);
      sizeElementFromChildren(span);
      if (color) {
        span.style.color = color;
      }
      return span;
    };
    var makeFragment = function(children) {
      var fragment = new domTree.documentFragment(children);
      sizeElementFromChildren(fragment);
      return fragment;
    };
    var makeFontSizer = function(options, fontSize) {
      var fontSizeInner = makeSpan([], [new domTree.symbolNode("â")]);
      fontSizeInner.style.fontSize = fontSize / options.style.sizeMultiplier + "em";
      var fontSizer = makeSpan(
        ["fontsize-ensurer", "reset-" + options.size, "size5"],
        [fontSizeInner]
      );
      return fontSizer;
    };
    var makeVList = function(children, positionType, positionData, options) {
      var depth;
      var currPos;
      var i;
      if (positionType === "individualShift") {
        var oldChildren = children;
        children = [oldChildren[0]];
        depth = -oldChildren[0].shift - oldChildren[0].elem.depth;
        currPos = depth;
        for (i = 1; i < oldChildren.length; i++) {
          var diff = -oldChildren[i].shift - currPos - oldChildren[i].elem.depth;
          var size = diff - (oldChildren[i - 1].elem.height + oldChildren[i - 1].elem.depth);
          currPos = currPos + diff;
          children.push({ type: "kern", size });
          children.push(oldChildren[i]);
        }
      } else if (positionType === "top") {
        var bottom = positionData;
        for (i = 0; i < children.length; i++) {
          if (children[i].type === "kern") {
            bottom -= children[i].size;
          } else {
            bottom -= children[i].elem.height + children[i].elem.depth;
          }
        }
        depth = bottom;
      } else if (positionType === "bottom") {
        depth = -positionData;
      } else if (positionType === "shift") {
        depth = -children[0].elem.depth - positionData;
      } else if (positionType === "firstBaseline") {
        depth = -children[0].elem.depth;
      } else {
        depth = 0;
      }
      var maxFontSize = 0;
      for (i = 0; i < children.length; i++) {
        if (children[i].type === "elem") {
          maxFontSize = Math.max(maxFontSize, children[i].elem.maxFontSize);
        }
      }
      var fontSizer = makeFontSizer(options, maxFontSize);
      var realChildren = [];
      currPos = depth;
      for (i = 0; i < children.length; i++) {
        if (children[i].type === "kern") {
          currPos += children[i].size;
        } else {
          var child = children[i].elem;
          var shift = -child.depth - currPos;
          currPos += child.height + child.depth;
          var childWrap = makeSpan([], [fontSizer, child]);
          childWrap.height -= shift;
          childWrap.depth += shift;
          childWrap.style.top = shift + "em";
          realChildren.push(childWrap);
        }
      }
      var baselineFix = makeSpan(
        ["baseline-fix"],
        [fontSizer, new domTree.symbolNode("â")]
      );
      realChildren.push(baselineFix);
      var vlist = makeSpan(["vlist"], realChildren);
      vlist.height = Math.max(currPos, vlist.height);
      vlist.depth = Math.max(-depth, vlist.depth);
      return vlist;
    };
    var sizingMultiplier = {
      size1: 0.5,
      size2: 0.7,
      size3: 0.8,
      size4: 0.9,
      size5: 1,
      size6: 1.2,
      size7: 1.44,
      size8: 1.73,
      size9: 2.07,
      size10: 2.49
    };
    var spacingFunctions = {
      "\\qquad": {
        size: "2em",
        className: "qquad"
      },
      "\\quad": {
        size: "1em",
        className: "quad"
      },
      "\\enspace": {
        size: "0.5em",
        className: "enspace"
      },
      "\\;": {
        size: "0.277778em",
        className: "thickspace"
      },
      "\\:": {
        size: "0.22222em",
        className: "mediumspace"
      },
      "\\,": {
        size: "0.16667em",
        className: "thinspace"
      },
      "\\!": {
        size: "-0.16667em",
        className: "negativethinspace"
      }
    };
    var fontMap = {
      // styles
      "mathbf": {
        variant: "bold",
        fontName: "Main-Bold"
      },
      "mathrm": {
        variant: "normal",
        fontName: "Main-Regular"
      },
      // "mathit" is missing because it requires the use of two fonts: Main-Italic
      // and Math-Italic.  This is handled by a special case in makeOrd which ends
      // up calling mathit.
      // families
      "mathbb": {
        variant: "double-struck",
        fontName: "AMS-Regular"
      },
      "mathcal": {
        variant: "script",
        fontName: "Caligraphic-Regular"
      },
      "mathfrak": {
        variant: "fraktur",
        fontName: "Fraktur-Regular"
      },
      "mathscr": {
        variant: "script",
        fontName: "Script-Regular"
      },
      "mathsf": {
        variant: "sans-serif",
        fontName: "SansSerif-Regular"
      },
      "mathtt": {
        variant: "monospace",
        fontName: "Typewriter-Regular"
      }
    };
    module.exports = {
      fontMap,
      makeSymbol,
      mathsym,
      makeSpan,
      makeFragment,
      makeVList,
      makeOrd,
      sizingMultiplier,
      spacingFunctions
    };
  }
});

// node_modules/katex/src/delimiter.js
var require_delimiter = __commonJS({
  "node_modules/katex/src/delimiter.js"(exports, module) {
    var ParseError = require_ParseError();
    var Style = require_Style();
    var buildCommon = require_buildCommon();
    var fontMetrics = require_fontMetrics();
    var symbols = require_symbols();
    var utils = require_utils();
    var makeSpan = buildCommon.makeSpan;
    var getMetrics = function(symbol, font) {
      if (symbols.math[symbol] && symbols.math[symbol].replace) {
        return fontMetrics.getCharacterMetrics(
          symbols.math[symbol].replace,
          font
        );
      } else {
        return fontMetrics.getCharacterMetrics(
          symbol,
          font
        );
      }
    };
    var mathrmSize = function(value, size, mode) {
      return buildCommon.makeSymbol(value, "Size" + size + "-Regular", mode);
    };
    var styleWrap = function(delim, toStyle, options) {
      var span = makeSpan(
        ["style-wrap", options.style.reset(), toStyle.cls()],
        [delim]
      );
      var multiplier = toStyle.sizeMultiplier / options.style.sizeMultiplier;
      span.height *= multiplier;
      span.depth *= multiplier;
      span.maxFontSize = toStyle.sizeMultiplier;
      return span;
    };
    var makeSmallDelim = function(delim, style, center, options, mode) {
      var text = buildCommon.makeSymbol(delim, "Main-Regular", mode);
      var span = styleWrap(text, style, options);
      if (center) {
        var shift = (1 - options.style.sizeMultiplier / style.sizeMultiplier) * fontMetrics.metrics.axisHeight;
        span.style.top = shift + "em";
        span.height -= shift;
        span.depth += shift;
      }
      return span;
    };
    var makeLargeDelim = function(delim, size, center, options, mode) {
      var inner = mathrmSize(delim, size, mode);
      var span = styleWrap(
        makeSpan(
          ["delimsizing", "size" + size],
          [inner],
          options.getColor()
        ),
        Style.TEXT,
        options
      );
      if (center) {
        var shift = (1 - options.style.sizeMultiplier) * fontMetrics.metrics.axisHeight;
        span.style.top = shift + "em";
        span.height -= shift;
        span.depth += shift;
      }
      return span;
    };
    var makeInner = function(symbol, font, mode) {
      var sizeClass;
      if (font === "Size1-Regular") {
        sizeClass = "delim-size1";
      } else if (font === "Size4-Regular") {
        sizeClass = "delim-size4";
      }
      var inner = makeSpan(
        ["delimsizinginner", sizeClass],
        [makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]
      );
      return { type: "elem", elem: inner };
    };
    var makeStackedDelim = function(delim, heightTotal, center, options, mode) {
      var top;
      var middle;
      var repeat;
      var bottom;
      top = repeat = bottom = delim;
      middle = null;
      var font = "Size1-Regular";
      if (delim === "\\uparrow") {
        repeat = bottom = "â";
      } else if (delim === "\\Uparrow") {
        repeat = bottom = "â";
      } else if (delim === "\\downarrow") {
        top = repeat = "â";
      } else if (delim === "\\Downarrow") {
        top = repeat = "â";
      } else if (delim === "\\updownarrow") {
        top = "\\uparrow";
        repeat = "â";
        bottom = "\\downarrow";
      } else if (delim === "\\Updownarrow") {
        top = "\\Uparrow";
        repeat = "â";
        bottom = "\\Downarrow";
      } else if (delim === "[" || delim === "\\lbrack") {
        top = "â¡";
        repeat = "â¢";
        bottom = "â£";
        font = "Size4-Regular";
      } else if (delim === "]" || delim === "\\rbrack") {
        top = "â¤";
        repeat = "â¥";
        bottom = "â¦";
        font = "Size4-Regular";
      } else if (delim === "\\lfloor") {
        repeat = top = "â¢";
        bottom = "â£";
        font = "Size4-Regular";
      } else if (delim === "\\lceil") {
        top = "â¡";
        repeat = bottom = "â¢";
        font = "Size4-Regular";
      } else if (delim === "\\rfloor") {
        repeat = top = "â¥";
        bottom = "â¦";
        font = "Size4-Regular";
      } else if (delim === "\\rceil") {
        top = "â¤";
        repeat = bottom = "â¥";
        font = "Size4-Regular";
      } else if (delim === "(") {
        top = "â";
        repeat = "â";
        bottom = "â";
        font = "Size4-Regular";
      } else if (delim === ")") {
        top = "â";
        repeat = "â";
        bottom = "â ";
        font = "Size4-Regular";
      } else if (delim === "\\{" || delim === "\\lbrace") {
        top = "â§";
        middle = "â¨";
        bottom = "â©";
        repeat = "âª";
        font = "Size4-Regular";
      } else if (delim === "\\}" || delim === "\\rbrace") {
        top = "â«";
        middle = "â¬";
        bottom = "â­";
        repeat = "âª";
        font = "Size4-Regular";
      } else if (delim === "\\lgroup") {
        top = "â§";
        bottom = "â©";
        repeat = "âª";
        font = "Size4-Regular";
      } else if (delim === "\\rgroup") {
        top = "â«";
        bottom = "â­";
        repeat = "âª";
        font = "Size4-Regular";
      } else if (delim === "\\lmoustache") {
        top = "â§";
        bottom = "â­";
        repeat = "âª";
        font = "Size4-Regular";
      } else if (delim === "\\rmoustache") {
        top = "â«";
        bottom = "â©";
        repeat = "âª";
        font = "Size4-Regular";
      } else if (delim === "\\surd") {
        top = "î";
        bottom = "â·";
        repeat = "î";
        font = "Size4-Regular";
      }
      var topMetrics = getMetrics(top, font);
      var topHeightTotal = topMetrics.height + topMetrics.depth;
      var repeatMetrics = getMetrics(repeat, font);
      var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
      var bottomMetrics = getMetrics(bottom, font);
      var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
      var middleHeightTotal = 0;
      var middleFactor = 1;
      if (middle !== null) {
        var middleMetrics = getMetrics(middle, font);
        middleHeightTotal = middleMetrics.height + middleMetrics.depth;
        middleFactor = 2;
      }
      var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;
      var repeatCount = Math.ceil(
        (heightTotal - minHeight) / (middleFactor * repeatHeightTotal)
      );
      var realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal;
      var axisHeight = fontMetrics.metrics.axisHeight;
      if (center) {
        axisHeight *= options.style.sizeMultiplier;
      }
      var depth = realHeightTotal / 2 - axisHeight;
      var inners = [];
      inners.push(makeInner(bottom, font, mode));
      var i;
      if (middle === null) {
        for (i = 0; i < repeatCount; i++) {
          inners.push(makeInner(repeat, font, mode));
        }
      } else {
        for (i = 0; i < repeatCount; i++) {
          inners.push(makeInner(repeat, font, mode));
        }
        inners.push(makeInner(middle, font, mode));
        for (i = 0; i < repeatCount; i++) {
          inners.push(makeInner(repeat, font, mode));
        }
      }
      inners.push(makeInner(top, font, mode));
      var inner = buildCommon.makeVList(inners, "bottom", depth, options);
      return styleWrap(
        makeSpan(["delimsizing", "mult"], [inner], options.getColor()),
        Style.TEXT,
        options
      );
    };
    var stackLargeDelimiters = [
      "(",
      ")",
      "[",
      "\\lbrack",
      "]",
      "\\rbrack",
      "\\{",
      "\\lbrace",
      "\\}",
      "\\rbrace",
      "\\lfloor",
      "\\rfloor",
      "\\lceil",
      "\\rceil",
      "\\surd"
    ];
    var stackAlwaysDelimiters = [
      "\\uparrow",
      "\\downarrow",
      "\\updownarrow",
      "\\Uparrow",
      "\\Downarrow",
      "\\Updownarrow",
      "|",
      "\\|",
      "\\vert",
      "\\Vert",
      "\\lvert",
      "\\rvert",
      "\\lVert",
      "\\rVert",
      "\\lgroup",
      "\\rgroup",
      "\\lmoustache",
      "\\rmoustache"
    ];
    var stackNeverDelimiters = [
      "<",
      ">",
      "\\langle",
      "\\rangle",
      "/",
      "\\backslash",
      "\\lt",
      "\\gt"
    ];
    var sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3];
    var makeSizedDelim = function(delim, size, options, mode) {
      if (delim === "<" || delim === "\\lt") {
        delim = "\\langle";
      } else if (delim === ">" || delim === "\\gt") {
        delim = "\\rangle";
      }
      if (utils.contains(stackLargeDelimiters, delim) || utils.contains(stackNeverDelimiters, delim)) {
        return makeLargeDelim(delim, size, false, options, mode);
      } else if (utils.contains(stackAlwaysDelimiters, delim)) {
        return makeStackedDelim(
          delim,
          sizeToMaxHeight[size],
          false,
          options,
          mode
        );
      } else {
        throw new ParseError("Illegal delimiter: '" + delim + "'");
      }
    };
    var stackNeverDelimiterSequence = [
      { type: "small", style: Style.SCRIPTSCRIPT },
      { type: "small", style: Style.SCRIPT },
      { type: "small", style: Style.TEXT },
      { type: "large", size: 1 },
      { type: "large", size: 2 },
      { type: "large", size: 3 },
      { type: "large", size: 4 }
    ];
    var stackAlwaysDelimiterSequence = [
      { type: "small", style: Style.SCRIPTSCRIPT },
      { type: "small", style: Style.SCRIPT },
      { type: "small", style: Style.TEXT },
      { type: "stack" }
    ];
    var stackLargeDelimiterSequence = [
      { type: "small", style: Style.SCRIPTSCRIPT },
      { type: "small", style: Style.SCRIPT },
      { type: "small", style: Style.TEXT },
      { type: "large", size: 1 },
      { type: "large", size: 2 },
      { type: "large", size: 3 },
      { type: "large", size: 4 },
      { type: "stack" }
    ];
    var delimTypeToFont = function(type) {
      if (type.type === "small") {
        return "Main-Regular";
      } else if (type.type === "large") {
        return "Size" + type.size + "-Regular";
      } else if (type.type === "stack") {
        return "Size4-Regular";
      }
    };
    var traverseSequence = function(delim, height, sequence, options) {
      var start = Math.min(2, 3 - options.style.size);
      for (var i = start; i < sequence.length; i++) {
        if (sequence[i].type === "stack") {
          break;
        }
        var metrics = getMetrics(delim, delimTypeToFont(sequence[i]));
        var heightDepth = metrics.height + metrics.depth;
        if (sequence[i].type === "small") {
          heightDepth *= sequence[i].style.sizeMultiplier;
        }
        if (heightDepth > height) {
          return sequence[i];
        }
      }
      return sequence[sequence.length - 1];
    };
    var makeCustomSizedDelim = function(delim, height, center, options, mode) {
      if (delim === "<" || delim === "\\lt") {
        delim = "\\langle";
      } else if (delim === ">" || delim === "\\gt") {
        delim = "\\rangle";
      }
      var sequence;
      if (utils.contains(stackNeverDelimiters, delim)) {
        sequence = stackNeverDelimiterSequence;
      } else if (utils.contains(stackLargeDelimiters, delim)) {
        sequence = stackLargeDelimiterSequence;
      } else {
        sequence = stackAlwaysDelimiterSequence;
      }
      var delimType = traverseSequence(delim, height, sequence, options);
      if (delimType.type === "small") {
        return makeSmallDelim(delim, delimType.style, center, options, mode);
      } else if (delimType.type === "large") {
        return makeLargeDelim(delim, delimType.size, center, options, mode);
      } else if (delimType.type === "stack") {
        return makeStackedDelim(delim, height, center, options, mode);
      }
    };
    var makeLeftRightDelim = function(delim, height, depth, options, mode) {
      var axisHeight = fontMetrics.metrics.axisHeight * options.style.sizeMultiplier;
      var delimiterFactor = 901;
      var delimiterExtend = 5 / fontMetrics.metrics.ptPerEm;
      var maxDistFromAxis = Math.max(
        height - axisHeight,
        depth + axisHeight
      );
      var totalHeight = Math.max(
        // In real TeX, calculations are done using integral values which are
        // 65536 per pt, or 655360 per em. So, the division here truncates in
        // TeX but doesn't here, producing different results. If we wanted to
        // exactly match TeX's calculation, we could do
        //   Math.floor(655360 * maxDistFromAxis / 500) *
        //    delimiterFactor / 655360
        // (To see the difference, compare
        //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
        // in TeX and KaTeX)
        maxDistFromAxis / 500 * delimiterFactor,
        2 * maxDistFromAxis - delimiterExtend
      );
      return makeCustomSizedDelim(delim, totalHeight, true, options, mode);
    };
    module.exports = {
      sizedDelim: makeSizedDelim,
      customSizedDelim: makeCustomSizedDelim,
      leftRightDelim: makeLeftRightDelim
    };
  }
});

// node_modules/katex/src/buildHTML.js
var require_buildHTML = __commonJS({
  "node_modules/katex/src/buildHTML.js"(exports, module) {
    var ParseError = require_ParseError();
    var Style = require_Style();
    var buildCommon = require_buildCommon();
    var delimiter = require_delimiter();
    var domTree = require_domTree();
    var fontMetrics = require_fontMetrics();
    var utils = require_utils();
    var makeSpan = buildCommon.makeSpan;
    var buildExpression = function(expression, options, prev) {
      var groups = [];
      for (var i = 0; i < expression.length; i++) {
        var group = expression[i];
        groups.push(buildGroup(group, options, prev));
        prev = group;
      }
      return groups;
    };
    var groupToType = {
      mathord: "mord",
      textord: "mord",
      bin: "mbin",
      rel: "mrel",
      text: "mord",
      open: "mopen",
      close: "mclose",
      inner: "minner",
      genfrac: "mord",
      array: "mord",
      spacing: "mord",
      punct: "mpunct",
      ordgroup: "mord",
      op: "mop",
      katex: "mord",
      overline: "mord",
      underline: "mord",
      rule: "mord",
      leftright: "minner",
      sqrt: "mord",
      accent: "mord"
    };
    var getTypeOfGroup = function(group) {
      if (group == null) {
        return groupToType.mathord;
      } else if (group.type === "supsub") {
        return getTypeOfGroup(group.value.base);
      } else if (group.type === "llap" || group.type === "rlap") {
        return getTypeOfGroup(group.value);
      } else if (group.type === "color") {
        return getTypeOfGroup(group.value.value);
      } else if (group.type === "sizing") {
        return getTypeOfGroup(group.value.value);
      } else if (group.type === "styling") {
        return getTypeOfGroup(group.value.value);
      } else if (group.type === "delimsizing") {
        return groupToType[group.value.delimType];
      } else {
        return groupToType[group.type];
      }
    };
    var shouldHandleSupSub = function(group, options) {
      if (!group) {
        return false;
      } else if (group.type === "op") {
        return group.value.limits && (options.style.size === Style.DISPLAY.size || group.value.alwaysHandleSupSub);
      } else if (group.type === "accent") {
        return isCharacterBox(group.value.base);
      } else {
        return null;
      }
    };
    var getBaseElem = function(group) {
      if (!group) {
        return false;
      } else if (group.type === "ordgroup") {
        if (group.value.length === 1) {
          return getBaseElem(group.value[0]);
        } else {
          return group;
        }
      } else if (group.type === "color") {
        if (group.value.value.length === 1) {
          return getBaseElem(group.value.value[0]);
        } else {
          return group;
        }
      } else {
        return group;
      }
    };
    var isCharacterBox = function(group) {
      var baseElem = getBaseElem(group);
      return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "bin" || baseElem.type === "rel" || baseElem.type === "inner" || baseElem.type === "open" || baseElem.type === "close" || baseElem.type === "punct";
    };
    var makeNullDelimiter = function(options) {
      return makeSpan([
        "sizing",
        "reset-" + options.size,
        "size5",
        options.style.reset(),
        Style.TEXT.cls(),
        "nulldelimiter"
      ]);
    };
    var groupTypes = {};
    groupTypes.mathord = function(group, options, prev) {
      return buildCommon.makeOrd(group, options, "mathord");
    };
    groupTypes.textord = function(group, options, prev) {
      return buildCommon.makeOrd(group, options, "textord");
    };
    groupTypes.bin = function(group, options, prev) {
      var className = "mbin";
      var prevAtom = prev;
      while (prevAtom && prevAtom.type === "color") {
        var atoms = prevAtom.value.value;
        prevAtom = atoms[atoms.length - 1];
      }
      if (!prev || utils.contains(
        ["mbin", "mopen", "mrel", "mop", "mpunct"],
        getTypeOfGroup(prevAtom)
      )) {
        group.type = "textord";
        className = "mord";
      }
      return buildCommon.mathsym(
        group.value,
        group.mode,
        options.getColor(),
        [className]
      );
    };
    groupTypes.rel = function(group, options, prev) {
      return buildCommon.mathsym(
        group.value,
        group.mode,
        options.getColor(),
        ["mrel"]
      );
    };
    groupTypes.open = function(group, options, prev) {
      return buildCommon.mathsym(
        group.value,
        group.mode,
        options.getColor(),
        ["mopen"]
      );
    };
    groupTypes.close = function(group, options, prev) {
      return buildCommon.mathsym(
        group.value,
        group.mode,
        options.getColor(),
        ["mclose"]
      );
    };
    groupTypes.inner = function(group, options, prev) {
      return buildCommon.mathsym(
        group.value,
        group.mode,
        options.getColor(),
        ["minner"]
      );
    };
    groupTypes.punct = function(group, options, prev) {
      return buildCommon.mathsym(
        group.value,
        group.mode,
        options.getColor(),
        ["mpunct"]
      );
    };
    groupTypes.ordgroup = function(group, options, prev) {
      return makeSpan(
        ["mord", options.style.cls()],
        buildExpression(group.value, options.reset())
      );
    };
    groupTypes.text = function(group, options, prev) {
      return makeSpan(
        ["text", "mord", options.style.cls()],
        buildExpression(group.value.body, options.reset())
      );
    };
    groupTypes.color = function(group, options, prev) {
      var elements = buildExpression(
        group.value.value,
        options.withColor(group.value.color),
        prev
      );
      return new buildCommon.makeFragment(elements);
    };
    groupTypes.supsub = function(group, options, prev) {
      if (shouldHandleSupSub(group.value.base, options)) {
        return groupTypes[group.value.base.type](group, options, prev);
      }
      var base = buildGroup(group.value.base, options.reset());
      var supmid;
      var submid;
      var sup;
      var sub;
      if (group.value.sup) {
        sup = buildGroup(
          group.value.sup,
          options.withStyle(options.style.sup())
        );
        supmid = makeSpan(
          [options.style.reset(), options.style.sup().cls()],
          [sup]
        );
      }
      if (group.value.sub) {
        sub = buildGroup(
          group.value.sub,
          options.withStyle(options.style.sub())
        );
        submid = makeSpan(
          [options.style.reset(), options.style.sub().cls()],
          [sub]
        );
      }
      var supShift;
      var subShift;
      if (isCharacterBox(group.value.base)) {
        supShift = 0;
        subShift = 0;
      } else {
        supShift = base.height - fontMetrics.metrics.supDrop;
        subShift = base.depth + fontMetrics.metrics.subDrop;
      }
      var minSupShift;
      if (options.style === Style.DISPLAY) {
        minSupShift = fontMetrics.metrics.sup1;
      } else if (options.style.cramped) {
        minSupShift = fontMetrics.metrics.sup3;
      } else {
        minSupShift = fontMetrics.metrics.sup2;
      }
      var multiplier = Style.TEXT.sizeMultiplier * options.style.sizeMultiplier;
      var scriptspace = 0.5 / fontMetrics.metrics.ptPerEm / multiplier + "em";
      var supsub;
      if (!group.value.sup) {
        subShift = Math.max(
          subShift,
          fontMetrics.metrics.sub1,
          sub.height - 0.8 * fontMetrics.metrics.xHeight
        );
        supsub = buildCommon.makeVList([
          { type: "elem", elem: submid }
        ], "shift", subShift, options);
        supsub.children[0].style.marginRight = scriptspace;
        if (base instanceof domTree.symbolNode) {
          supsub.children[0].style.marginLeft = -base.italic + "em";
        }
      } else if (!group.value.sub) {
        supShift = Math.max(
          supShift,
          minSupShift,
          sup.depth + 0.25 * fontMetrics.metrics.xHeight
        );
        supsub = buildCommon.makeVList([
          { type: "elem", elem: supmid }
        ], "shift", -supShift, options);
        supsub.children[0].style.marginRight = scriptspace;
      } else {
        supShift = Math.max(
          supShift,
          minSupShift,
          sup.depth + 0.25 * fontMetrics.metrics.xHeight
        );
        subShift = Math.max(subShift, fontMetrics.metrics.sub2);
        var ruleWidth = fontMetrics.metrics.defaultRuleThickness;
        if (supShift - sup.depth - (sub.height - subShift) < 4 * ruleWidth) {
          subShift = 4 * ruleWidth - (supShift - sup.depth) + sub.height;
          var psi = 0.8 * fontMetrics.metrics.xHeight - (supShift - sup.depth);
          if (psi > 0) {
            supShift += psi;
            subShift -= psi;
          }
        }
        supsub = buildCommon.makeVList([
          { type: "elem", elem: submid, shift: subShift },
          { type: "elem", elem: supmid, shift: -supShift }
        ], "individualShift", null, options);
        if (base instanceof domTree.symbolNode) {
          supsub.children[0].style.marginLeft = -base.italic + "em";
        }
        supsub.children[0].style.marginRight = scriptspace;
        supsub.children[1].style.marginRight = scriptspace;
      }
      return makeSpan(
        [getTypeOfGroup(group.value.base)],
        [base, supsub]
      );
    };
    groupTypes.genfrac = function(group, options, prev) {
      var fstyle = options.style;
      if (group.value.size === "display") {
        fstyle = Style.DISPLAY;
      } else if (group.value.size === "text") {
        fstyle = Style.TEXT;
      }
      var nstyle = fstyle.fracNum();
      var dstyle = fstyle.fracDen();
      var numer = buildGroup(group.value.numer, options.withStyle(nstyle));
      var numerreset = makeSpan([fstyle.reset(), nstyle.cls()], [numer]);
      var denom = buildGroup(group.value.denom, options.withStyle(dstyle));
      var denomreset = makeSpan([fstyle.reset(), dstyle.cls()], [denom]);
      var ruleWidth;
      if (group.value.hasBarLine) {
        ruleWidth = fontMetrics.metrics.defaultRuleThickness / options.style.sizeMultiplier;
      } else {
        ruleWidth = 0;
      }
      var numShift;
      var clearance;
      var denomShift;
      if (fstyle.size === Style.DISPLAY.size) {
        numShift = fontMetrics.metrics.num1;
        if (ruleWidth > 0) {
          clearance = 3 * ruleWidth;
        } else {
          clearance = 7 * fontMetrics.metrics.defaultRuleThickness;
        }
        denomShift = fontMetrics.metrics.denom1;
      } else {
        if (ruleWidth > 0) {
          numShift = fontMetrics.metrics.num2;
          clearance = ruleWidth;
        } else {
          numShift = fontMetrics.metrics.num3;
          clearance = 3 * fontMetrics.metrics.defaultRuleThickness;
        }
        denomShift = fontMetrics.metrics.denom2;
      }
      var frac;
      if (ruleWidth === 0) {
        var candiateClearance = numShift - numer.depth - (denom.height - denomShift);
        if (candiateClearance < clearance) {
          numShift += 0.5 * (clearance - candiateClearance);
          denomShift += 0.5 * (clearance - candiateClearance);
        }
        frac = buildCommon.makeVList([
          { type: "elem", elem: denomreset, shift: denomShift },
          { type: "elem", elem: numerreset, shift: -numShift }
        ], "individualShift", null, options);
      } else {
        var axisHeight = fontMetrics.metrics.axisHeight;
        if (numShift - numer.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {
          numShift += clearance - (numShift - numer.depth - (axisHeight + 0.5 * ruleWidth));
        }
        if (axisHeight - 0.5 * ruleWidth - (denom.height - denomShift) < clearance) {
          denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denom.height - denomShift));
        }
        var mid = makeSpan(
          [options.style.reset(), Style.TEXT.cls(), "frac-line"]
        );
        mid.height = ruleWidth;
        var midShift = -(axisHeight - 0.5 * ruleWidth);
        frac = buildCommon.makeVList([
          { type: "elem", elem: denomreset, shift: denomShift },
          { type: "elem", elem: mid, shift: midShift },
          { type: "elem", elem: numerreset, shift: -numShift }
        ], "individualShift", null, options);
      }
      frac.height *= fstyle.sizeMultiplier / options.style.sizeMultiplier;
      frac.depth *= fstyle.sizeMultiplier / options.style.sizeMultiplier;
      var delimSize;
      if (fstyle.size === Style.DISPLAY.size) {
        delimSize = fontMetrics.metrics.delim1;
      } else {
        delimSize = fontMetrics.metrics.getDelim2(fstyle);
      }
      var leftDelim;
      var rightDelim;
      if (group.value.leftDelim == null) {
        leftDelim = makeNullDelimiter(options);
      } else {
        leftDelim = delimiter.customSizedDelim(
          group.value.leftDelim,
          delimSize,
          true,
          options.withStyle(fstyle),
          group.mode
        );
      }
      if (group.value.rightDelim == null) {
        rightDelim = makeNullDelimiter(options);
      } else {
        rightDelim = delimiter.customSizedDelim(
          group.value.rightDelim,
          delimSize,
          true,
          options.withStyle(fstyle),
          group.mode
        );
      }
      return makeSpan(
        ["mord", options.style.reset(), fstyle.cls()],
        [leftDelim, makeSpan(["mfrac"], [frac]), rightDelim],
        options.getColor()
      );
    };
    groupTypes.array = function(group, options, prev) {
      var r;
      var c;
      var nr = group.value.body.length;
      var nc = 0;
      var body = new Array(nr);
      var pt = 1 / fontMetrics.metrics.ptPerEm;
      var arraycolsep = 5 * pt;
      var baselineskip = 12 * pt;
      var arraystretch = utils.deflt(group.value.arraystretch, 1);
      var arrayskip = arraystretch * baselineskip;
      var arstrutHeight = 0.7 * arrayskip;
      var arstrutDepth = 0.3 * arrayskip;
      var totalHeight = 0;
      for (r = 0; r < group.value.body.length; ++r) {
        var inrow = group.value.body[r];
        var height = arstrutHeight;
        var depth = arstrutDepth;
        if (nc < inrow.length) {
          nc = inrow.length;
        }
        var outrow = new Array(inrow.length);
        for (c = 0; c < inrow.length; ++c) {
          var elt = buildGroup(inrow[c], options);
          if (depth < elt.depth) {
            depth = elt.depth;
          }
          if (height < elt.height) {
            height = elt.height;
          }
          outrow[c] = elt;
        }
        var gap = 0;
        if (group.value.rowGaps[r]) {
          gap = group.value.rowGaps[r].value;
          switch (gap.unit) {
            case "em":
              gap = gap.number;
              break;
            case "ex":
              gap = gap.number * fontMetrics.metrics.emPerEx;
              break;
            default:
              console.error("Can't handle unit " + gap.unit);
              gap = 0;
          }
          if (gap > 0) {
            gap += arstrutDepth;
            if (depth < gap) {
              depth = gap;
            }
            gap = 0;
          }
        }
        outrow.height = height;
        outrow.depth = depth;
        totalHeight += height;
        outrow.pos = totalHeight;
        totalHeight += depth + gap;
        body[r] = outrow;
      }
      var offset = totalHeight / 2 + fontMetrics.metrics.axisHeight;
      var colDescriptions = group.value.cols || [];
      var cols = [];
      var colSep;
      var colDescrNum;
      for (
        c = 0, colDescrNum = 0;
        // Continue while either there are more columns or more column
        // descriptions, so trailing separators don't get lost.
        c < nc || colDescrNum < colDescriptions.length;
        ++c, ++colDescrNum
      ) {
        var colDescr = colDescriptions[colDescrNum] || {};
        var firstSeparator = true;
        while (colDescr.type === "separator") {
          if (!firstSeparator) {
            colSep = makeSpan(["arraycolsep"], []);
            colSep.style.width = fontMetrics.metrics.doubleRuleSep + "em";
            cols.push(colSep);
          }
          if (colDescr.separator === "|") {
            var separator = makeSpan(
              ["vertical-separator"],
              []
            );
            separator.style.height = totalHeight + "em";
            separator.style.verticalAlign = -(totalHeight - offset) + "em";
            cols.push(separator);
          } else {
            throw new ParseError(
              "Invalid separator type: " + colDescr.separator
            );
          }
          colDescrNum++;
          colDescr = colDescriptions[colDescrNum] || {};
          firstSeparator = false;
        }
        if (c >= nc) {
          continue;
        }
        var sepwidth;
        if (c > 0 || group.value.hskipBeforeAndAfter) {
          sepwidth = utils.deflt(colDescr.pregap, arraycolsep);
          if (sepwidth !== 0) {
            colSep = makeSpan(["arraycolsep"], []);
            colSep.style.width = sepwidth + "em";
            cols.push(colSep);
          }
        }
        var col = [];
        for (r = 0; r < nr; ++r) {
          var row = body[r];
          var elem = row[c];
          if (!elem) {
            continue;
          }
          var shift = row.pos - offset;
          elem.depth = row.depth;
          elem.height = row.height;
          col.push({ type: "elem", elem, shift });
        }
        col = buildCommon.makeVList(col, "individualShift", null, options);
        col = makeSpan(
          ["col-align-" + (colDescr.align || "c")],
          [col]
        );
        cols.push(col);
        if (c < nc - 1 || group.value.hskipBeforeAndAfter) {
          sepwidth = utils.deflt(colDescr.postgap, arraycolsep);
          if (sepwidth !== 0) {
            colSep = makeSpan(["arraycolsep"], []);
            colSep.style.width = sepwidth + "em";
            cols.push(colSep);
          }
        }
      }
      body = makeSpan(["mtable"], cols);
      return makeSpan(["mord"], [body], options.getColor());
    };
    groupTypes.spacing = function(group, options, prev) {
      if (group.value === "\\ " || group.value === "\\space" || group.value === " " || group.value === "~") {
        return makeSpan(
          ["mord", "mspace"],
          [buildCommon.mathsym(group.value, group.mode)]
        );
      } else {
        return makeSpan(
          [
            "mord",
            "mspace",
            buildCommon.spacingFunctions[group.value].className
          ]
        );
      }
    };
    groupTypes.llap = function(group, options, prev) {
      var inner = makeSpan(
        ["inner"],
        [buildGroup(group.value.body, options.reset())]
      );
      var fix = makeSpan(["fix"], []);
      return makeSpan(
        ["llap", options.style.cls()],
        [inner, fix]
      );
    };
    groupTypes.rlap = function(group, options, prev) {
      var inner = makeSpan(
        ["inner"],
        [buildGroup(group.value.body, options.reset())]
      );
      var fix = makeSpan(["fix"], []);
      return makeSpan(
        ["rlap", options.style.cls()],
        [inner, fix]
      );
    };
    groupTypes.op = function(group, options, prev) {
      var supGroup;
      var subGroup;
      var hasLimits = false;
      if (group.type === "supsub") {
        supGroup = group.value.sup;
        subGroup = group.value.sub;
        group = group.value.base;
        hasLimits = true;
      }
      var noSuccessor = [
        "\\smallint"
      ];
      var large = false;
      if (options.style.size === Style.DISPLAY.size && group.value.symbol && !utils.contains(noSuccessor, group.value.body)) {
        large = true;
      }
      var base;
      var baseShift = 0;
      var slant = 0;
      if (group.value.symbol) {
        var style = large ? "Size2-Regular" : "Size1-Regular";
        base = buildCommon.makeSymbol(
          group.value.body,
          style,
          "math",
          options.getColor(),
          ["op-symbol", large ? "large-op" : "small-op", "mop"]
        );
        baseShift = (base.height - base.depth) / 2 - fontMetrics.metrics.axisHeight * options.style.sizeMultiplier;
        slant = base.italic;
      } else {
        var output = [];
        for (var i = 1; i < group.value.body.length; i++) {
          output.push(buildCommon.mathsym(group.value.body[i], group.mode));
        }
        base = makeSpan(["mop"], output, options.getColor());
      }
      if (hasLimits) {
        base = makeSpan([], [base]);
        var supmid;
        var supKern;
        var submid;
        var subKern;
        if (supGroup) {
          var sup = buildGroup(
            supGroup,
            options.withStyle(options.style.sup())
          );
          supmid = makeSpan(
            [options.style.reset(), options.style.sup().cls()],
            [sup]
          );
          supKern = Math.max(
            fontMetrics.metrics.bigOpSpacing1,
            fontMetrics.metrics.bigOpSpacing3 - sup.depth
          );
        }
        if (subGroup) {
          var sub = buildGroup(
            subGroup,
            options.withStyle(options.style.sub())
          );
          submid = makeSpan(
            [options.style.reset(), options.style.sub().cls()],
            [sub]
          );
          subKern = Math.max(
            fontMetrics.metrics.bigOpSpacing2,
            fontMetrics.metrics.bigOpSpacing4 - sub.height
          );
        }
        var finalGroup;
        var top;
        var bottom;
        if (!supGroup) {
          top = base.height - baseShift;
          finalGroup = buildCommon.makeVList([
            { type: "kern", size: fontMetrics.metrics.bigOpSpacing5 },
            { type: "elem", elem: submid },
            { type: "kern", size: subKern },
            { type: "elem", elem: base }
          ], "top", top, options);
          finalGroup.children[0].style.marginLeft = -slant + "em";
        } else if (!subGroup) {
          bottom = base.depth + baseShift;
          finalGroup = buildCommon.makeVList([
            { type: "elem", elem: base },
            { type: "kern", size: supKern },
            { type: "elem", elem: supmid },
            { type: "kern", size: fontMetrics.metrics.bigOpSpacing5 }
          ], "bottom", bottom, options);
          finalGroup.children[1].style.marginLeft = slant + "em";
        } else if (!supGroup && !subGroup) {
          return base;
        } else {
          bottom = fontMetrics.metrics.bigOpSpacing5 + submid.height + submid.depth + subKern + base.depth + baseShift;
          finalGroup = buildCommon.makeVList([
            { type: "kern", size: fontMetrics.metrics.bigOpSpacing5 },
            { type: "elem", elem: submid },
            { type: "kern", size: subKern },
            { type: "elem", elem: base },
            { type: "kern", size: supKern },
            { type: "elem", elem: supmid },
            { type: "kern", size: fontMetrics.metrics.bigOpSpacing5 }
          ], "bottom", bottom, options);
          finalGroup.children[0].style.marginLeft = -slant + "em";
          finalGroup.children[2].style.marginLeft = slant + "em";
        }
        return makeSpan(["mop", "op-limits"], [finalGroup]);
      } else {
        if (group.value.symbol) {
          base.style.top = baseShift + "em";
        }
        return base;
      }
    };
    groupTypes.katex = function(group, options, prev) {
      var k = makeSpan(
        ["k"],
        [buildCommon.mathsym("K", group.mode)]
      );
      var a = makeSpan(
        ["a"],
        [buildCommon.mathsym("A", group.mode)]
      );
      a.height = (a.height + 0.2) * 0.75;
      a.depth = (a.height - 0.2) * 0.75;
      var t = makeSpan(
        ["t"],
        [buildCommon.mathsym("T", group.mode)]
      );
      var e = makeSpan(
        ["e"],
        [buildCommon.mathsym("E", group.mode)]
      );
      e.height = e.height - 0.2155;
      e.depth = e.depth + 0.2155;
      var x = makeSpan(
        ["x"],
        [buildCommon.mathsym("X", group.mode)]
      );
      return makeSpan(
        ["katex-logo", "mord"],
        [k, a, t, e, x],
        options.getColor()
      );
    };
    groupTypes.overline = function(group, options, prev) {
      var innerGroup = buildGroup(
        group.value.body,
        options.withStyle(options.style.cramp())
      );
      var ruleWidth = fontMetrics.metrics.defaultRuleThickness / options.style.sizeMultiplier;
      var line = makeSpan(
        [options.style.reset(), Style.TEXT.cls(), "overline-line"]
      );
      line.height = ruleWidth;
      line.maxFontSize = 1;
      var vlist = buildCommon.makeVList([
        { type: "elem", elem: innerGroup },
        { type: "kern", size: 3 * ruleWidth },
        { type: "elem", elem: line },
        { type: "kern", size: ruleWidth }
      ], "firstBaseline", null, options);
      return makeSpan(["overline", "mord"], [vlist], options.getColor());
    };
    groupTypes.underline = function(group, options, prev) {
      var innerGroup = buildGroup(group.value.body, options);
      var ruleWidth = fontMetrics.metrics.defaultRuleThickness / options.style.sizeMultiplier;
      var line = makeSpan(
        [options.style.reset(), Style.TEXT.cls(), "underline-line"]
      );
      line.height = ruleWidth;
      line.maxFontSize = 1;
      var vlist = buildCommon.makeVList([
        { type: "kern", size: ruleWidth },
        { type: "elem", elem: line },
        { type: "kern", size: 3 * ruleWidth },
        { type: "elem", elem: innerGroup }
      ], "top", innerGroup.height, options);
      return makeSpan(["underline", "mord"], [vlist], options.getColor());
    };
    groupTypes.sqrt = function(group, options, prev) {
      var inner = buildGroup(
        group.value.body,
        options.withStyle(options.style.cramp())
      );
      var ruleWidth = fontMetrics.metrics.defaultRuleThickness / options.style.sizeMultiplier;
      var line = makeSpan(
        [options.style.reset(), Style.TEXT.cls(), "sqrt-line"],
        [],
        options.getColor()
      );
      line.height = ruleWidth;
      line.maxFontSize = 1;
      var phi = ruleWidth;
      if (options.style.id < Style.TEXT.id) {
        phi = fontMetrics.metrics.xHeight;
      }
      var lineClearance = ruleWidth + phi / 4;
      var innerHeight = (inner.height + inner.depth) * options.style.sizeMultiplier;
      var minDelimiterHeight = innerHeight + lineClearance + ruleWidth;
      var delim = makeSpan(
        ["sqrt-sign"],
        [
          delimiter.customSizedDelim(
            "\\surd",
            minDelimiterHeight,
            false,
            options,
            group.mode
          )
        ],
        options.getColor()
      );
      var delimDepth = delim.height + delim.depth - ruleWidth;
      if (delimDepth > inner.height + inner.depth + lineClearance) {
        lineClearance = (lineClearance + delimDepth - inner.height - inner.depth) / 2;
      }
      var delimShift = -(inner.height + lineClearance + ruleWidth) + delim.height;
      delim.style.top = delimShift + "em";
      delim.height -= delimShift;
      delim.depth += delimShift;
      var body;
      if (inner.height === 0 && inner.depth === 0) {
        body = makeSpan();
      } else {
        body = buildCommon.makeVList([
          { type: "elem", elem: inner },
          { type: "kern", size: lineClearance },
          { type: "elem", elem: line },
          { type: "kern", size: ruleWidth }
        ], "firstBaseline", null, options);
      }
      if (!group.value.index) {
        return makeSpan(["sqrt", "mord"], [delim, body]);
      } else {
        var root = buildGroup(
          group.value.index,
          options.withStyle(Style.SCRIPTSCRIPT)
        );
        var rootWrap = makeSpan(
          [options.style.reset(), Style.SCRIPTSCRIPT.cls()],
          [root]
        );
        var innerRootHeight = Math.max(delim.height, body.height);
        var innerRootDepth = Math.max(delim.depth, body.depth);
        var toShift = 0.6 * (innerRootHeight - innerRootDepth);
        var rootVList = buildCommon.makeVList(
          [{ type: "elem", elem: rootWrap }],
          "shift",
          -toShift,
          options
        );
        var rootVListWrap = makeSpan(["root"], [rootVList]);
        return makeSpan(["sqrt", "mord"], [rootVListWrap, delim, body]);
      }
    };
    groupTypes.sizing = function(group, options, prev) {
      var inner = buildExpression(
        group.value.value,
        options.withSize(group.value.size),
        prev
      );
      var span = makeSpan(
        ["mord"],
        [makeSpan(
          [
            "sizing",
            "reset-" + options.size,
            group.value.size,
            options.style.cls()
          ],
          inner
        )]
      );
      var fontSize = buildCommon.sizingMultiplier[group.value.size];
      span.maxFontSize = fontSize * options.style.sizeMultiplier;
      return span;
    };
    groupTypes.styling = function(group, options, prev) {
      var style = {
        "display": Style.DISPLAY,
        "text": Style.TEXT,
        "script": Style.SCRIPT,
        "scriptscript": Style.SCRIPTSCRIPT
      };
      var newStyle = style[group.value.style];
      var inner = buildExpression(
        group.value.value,
        options.withStyle(newStyle),
        prev
      );
      return makeSpan([options.style.reset(), newStyle.cls()], inner);
    };
    groupTypes.font = function(group, options, prev) {
      var font = group.value.font;
      return buildGroup(group.value.body, options.withFont(font), prev);
    };
    groupTypes.delimsizing = function(group, options, prev) {
      var delim = group.value.value;
      if (delim === ".") {
        return makeSpan([groupToType[group.value.delimType]]);
      }
      return makeSpan(
        [groupToType[group.value.delimType]],
        [delimiter.sizedDelim(
          delim,
          group.value.size,
          options,
          group.mode
        )]
      );
    };
    groupTypes.leftright = function(group, options, prev) {
      var inner = buildExpression(group.value.body, options.reset());
      var innerHeight = 0;
      var innerDepth = 0;
      for (var i = 0; i < inner.length; i++) {
        innerHeight = Math.max(inner[i].height, innerHeight);
        innerDepth = Math.max(inner[i].depth, innerDepth);
      }
      innerHeight *= options.style.sizeMultiplier;
      innerDepth *= options.style.sizeMultiplier;
      var leftDelim;
      if (group.value.left === ".") {
        leftDelim = makeNullDelimiter(options);
      } else {
        leftDelim = delimiter.leftRightDelim(
          group.value.left,
          innerHeight,
          innerDepth,
          options,
          group.mode
        );
      }
      inner.unshift(leftDelim);
      var rightDelim;
      if (group.value.right === ".") {
        rightDelim = makeNullDelimiter(options);
      } else {
        rightDelim = delimiter.leftRightDelim(
          group.value.right,
          innerHeight,
          innerDepth,
          options,
          group.mode
        );
      }
      inner.push(rightDelim);
      return makeSpan(
        ["minner", options.style.cls()],
        inner,
        options.getColor()
      );
    };
    groupTypes.rule = function(group, options, prev) {
      var rule = makeSpan(["mord", "rule"], [], options.getColor());
      var shift = 0;
      if (group.value.shift) {
        shift = group.value.shift.number;
        if (group.value.shift.unit === "ex") {
          shift *= fontMetrics.metrics.xHeight;
        }
      }
      var width = group.value.width.number;
      if (group.value.width.unit === "ex") {
        width *= fontMetrics.metrics.xHeight;
      }
      var height = group.value.height.number;
      if (group.value.height.unit === "ex") {
        height *= fontMetrics.metrics.xHeight;
      }
      shift /= options.style.sizeMultiplier;
      width /= options.style.sizeMultiplier;
      height /= options.style.sizeMultiplier;
      rule.style.borderRightWidth = width + "em";
      rule.style.borderTopWidth = height + "em";
      rule.style.bottom = shift + "em";
      rule.width = width;
      rule.height = height + shift;
      rule.depth = -shift;
      return rule;
    };
    groupTypes.accent = function(group, options, prev) {
      var base = group.value.base;
      var supsubGroup;
      if (group.type === "supsub") {
        var supsub = group;
        group = supsub.value.base;
        base = group.value.base;
        supsub.value.base = base;
        supsubGroup = buildGroup(
          supsub,
          options.reset(),
          prev
        );
      }
      var body = buildGroup(
        base,
        options.withStyle(options.style.cramp())
      );
      var skew;
      if (isCharacterBox(base)) {
        var baseChar = getBaseElem(base);
        var baseGroup = buildGroup(
          baseChar,
          options.withStyle(options.style.cramp())
        );
        skew = baseGroup.skew;
      } else {
        skew = 0;
      }
      var clearance = Math.min(body.height, fontMetrics.metrics.xHeight);
      var accent = buildCommon.makeSymbol(
        group.value.accent,
        "Main-Regular",
        "math",
        options.getColor()
      );
      accent.italic = 0;
      var vecClass = group.value.accent === "\\vec" ? "accent-vec" : null;
      var accentBody = makeSpan(["accent-body", vecClass], [
        makeSpan([], [accent])
      ]);
      accentBody = buildCommon.makeVList([
        { type: "elem", elem: body },
        { type: "kern", size: -clearance },
        { type: "elem", elem: accentBody }
      ], "firstBaseline", null, options);
      accentBody.children[1].style.marginLeft = 2 * skew + "em";
      var accentWrap = makeSpan(["mord", "accent"], [accentBody]);
      if (supsubGroup) {
        supsubGroup.children[0] = accentWrap;
        supsubGroup.height = Math.max(accentWrap.height, supsubGroup.height);
        supsubGroup.classes[0] = "mord";
        return supsubGroup;
      } else {
        return accentWrap;
      }
    };
    groupTypes.phantom = function(group, options, prev) {
      var elements = buildExpression(
        group.value.value,
        options.withPhantom(),
        prev
      );
      return new buildCommon.makeFragment(elements);
    };
    var buildGroup = function(group, options, prev) {
      if (!group) {
        return makeSpan();
      }
      if (groupTypes[group.type]) {
        var groupNode = groupTypes[group.type](group, options, prev);
        var multiplier;
        if (options.style !== options.parentStyle) {
          multiplier = options.style.sizeMultiplier / options.parentStyle.sizeMultiplier;
          groupNode.height *= multiplier;
          groupNode.depth *= multiplier;
        }
        if (options.size !== options.parentSize) {
          multiplier = buildCommon.sizingMultiplier[options.size] / buildCommon.sizingMultiplier[options.parentSize];
          groupNode.height *= multiplier;
          groupNode.depth *= multiplier;
        }
        return groupNode;
      } else {
        throw new ParseError(
          "Got group of unknown type: '" + group.type + "'"
        );
      }
    };
    var buildHTML = function(tree, options) {
      tree = JSON.parse(JSON.stringify(tree));
      var expression = buildExpression(tree, options);
      var body = makeSpan(["base", options.style.cls()], expression);
      var topStrut = makeSpan(["strut"]);
      var bottomStrut = makeSpan(["strut", "bottom"]);
      topStrut.style.height = body.height + "em";
      bottomStrut.style.height = body.height + body.depth + "em";
      bottomStrut.style.verticalAlign = -body.depth + "em";
      var htmlNode = makeSpan(["katex-html"], [topStrut, bottomStrut, body]);
      htmlNode.setAttribute("aria-hidden", "true");
      return htmlNode;
    };
    module.exports = buildHTML;
  }
});

// node_modules/katex/src/mathMLTree.js
var require_mathMLTree = __commonJS({
  "node_modules/katex/src/mathMLTree.js"(exports, module) {
    var utils = require_utils();
    function MathNode(type, children) {
      this.type = type;
      this.attributes = {};
      this.children = children || [];
    }
    MathNode.prototype.setAttribute = function(name, value) {
      this.attributes[name] = value;
    };
    MathNode.prototype.toNode = function() {
      var node = document.createElementNS(
        "http://www.w3.org/1998/Math/MathML",
        this.type
      );
      for (var attr in this.attributes) {
        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
          node.setAttribute(attr, this.attributes[attr]);
        }
      }
      for (var i = 0; i < this.children.length; i++) {
        node.appendChild(this.children[i].toNode());
      }
      return node;
    };
    MathNode.prototype.toMarkup = function() {
      var markup = "<" + this.type;
      for (var attr in this.attributes) {
        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
          markup += " " + attr + '="';
          markup += utils.escape(this.attributes[attr]);
          markup += '"';
        }
      }
      markup += ">";
      for (var i = 0; i < this.children.length; i++) {
        markup += this.children[i].toMarkup();
      }
      markup += "</" + this.type + ">";
      return markup;
    };
    function TextNode(text) {
      this.text = text;
    }
    TextNode.prototype.toNode = function() {
      return document.createTextNode(this.text);
    };
    TextNode.prototype.toMarkup = function() {
      return utils.escape(this.text);
    };
    module.exports = {
      MathNode,
      TextNode
    };
  }
});

// node_modules/katex/src/buildMathML.js
var require_buildMathML = __commonJS({
  "node_modules/katex/src/buildMathML.js"(exports, module) {
    var buildCommon = require_buildCommon();
    var fontMetrics = require_fontMetrics();
    var mathMLTree = require_mathMLTree();
    var ParseError = require_ParseError();
    var symbols = require_symbols();
    var utils = require_utils();
    var makeSpan = buildCommon.makeSpan;
    var fontMap = buildCommon.fontMap;
    var makeText = function(text, mode) {
      if (symbols[mode][text] && symbols[mode][text].replace) {
        text = symbols[mode][text].replace;
      }
      return new mathMLTree.TextNode(text);
    };
    var getVariant = function(group, options) {
      var font = options.font;
      if (!font) {
        return null;
      }
      var mode = group.mode;
      if (font === "mathit") {
        return "italic";
      }
      var value = group.value;
      if (utils.contains(["\\imath", "\\jmath"], value)) {
        return null;
      }
      if (symbols[mode][value] && symbols[mode][value].replace) {
        value = symbols[mode][value].replace;
      }
      var fontName = fontMap[font].fontName;
      if (fontMetrics.getCharacterMetrics(value, fontName)) {
        return fontMap[options.font].variant;
      }
      return null;
    };
    var groupTypes = {};
    groupTypes.mathord = function(group, options) {
      var node = new mathMLTree.MathNode(
        "mi",
        [makeText(group.value, group.mode)]
      );
      var variant = getVariant(group, options);
      if (variant) {
        node.setAttribute("mathvariant", variant);
      }
      return node;
    };
    groupTypes.textord = function(group, options) {
      var text = makeText(group.value, group.mode);
      var variant = getVariant(group, options) || "normal";
      var node;
      if (/[0-9]/.test(group.value)) {
        node = new mathMLTree.MathNode("mn", [text]);
        if (options.font) {
          node.setAttribute("mathvariant", variant);
        }
      } else {
        node = new mathMLTree.MathNode("mi", [text]);
        node.setAttribute("mathvariant", variant);
      }
      return node;
    };
    groupTypes.bin = function(group) {
      var node = new mathMLTree.MathNode(
        "mo",
        [makeText(group.value, group.mode)]
      );
      return node;
    };
    groupTypes.rel = function(group) {
      var node = new mathMLTree.MathNode(
        "mo",
        [makeText(group.value, group.mode)]
      );
      return node;
    };
    groupTypes.open = function(group) {
      var node = new mathMLTree.MathNode(
        "mo",
        [makeText(group.value, group.mode)]
      );
      return node;
    };
    groupTypes.close = function(group) {
      var node = new mathMLTree.MathNode(
        "mo",
        [makeText(group.value, group.mode)]
      );
      return node;
    };
    groupTypes.inner = function(group) {
      var node = new mathMLTree.MathNode(
        "mo",
        [makeText(group.value, group.mode)]
      );
      return node;
    };
    groupTypes.punct = function(group) {
      var node = new mathMLTree.MathNode(
        "mo",
        [makeText(group.value, group.mode)]
      );
      node.setAttribute("separator", "true");
      return node;
    };
    groupTypes.ordgroup = function(group, options) {
      var inner = buildExpression(group.value, options);
      var node = new mathMLTree.MathNode("mrow", inner);
      return node;
    };
    groupTypes.text = function(group, options) {
      var inner = buildExpression(group.value.body, options);
      var node = new mathMLTree.MathNode("mtext", inner);
      return node;
    };
    groupTypes.color = function(group, options) {
      var inner = buildExpression(group.value.value, options);
      var node = new mathMLTree.MathNode("mstyle", inner);
      node.setAttribute("mathcolor", group.value.color);
      return node;
    };
    groupTypes.supsub = function(group, options) {
      var children = [buildGroup(group.value.base, options)];
      if (group.value.sub) {
        children.push(buildGroup(group.value.sub, options));
      }
      if (group.value.sup) {
        children.push(buildGroup(group.value.sup, options));
      }
      var nodeType;
      if (!group.value.sub) {
        nodeType = "msup";
      } else if (!group.value.sup) {
        nodeType = "msub";
      } else {
        nodeType = "msubsup";
      }
      var node = new mathMLTree.MathNode(nodeType, children);
      return node;
    };
    groupTypes.genfrac = function(group, options) {
      var node = new mathMLTree.MathNode(
        "mfrac",
        [
          buildGroup(group.value.numer, options),
          buildGroup(group.value.denom, options)
        ]
      );
      if (!group.value.hasBarLine) {
        node.setAttribute("linethickness", "0px");
      }
      if (group.value.leftDelim != null || group.value.rightDelim != null) {
        var withDelims = [];
        if (group.value.leftDelim != null) {
          var leftOp = new mathMLTree.MathNode(
            "mo",
            [new mathMLTree.TextNode(group.value.leftDelim)]
          );
          leftOp.setAttribute("fence", "true");
          withDelims.push(leftOp);
        }
        withDelims.push(node);
        if (group.value.rightDelim != null) {
          var rightOp = new mathMLTree.MathNode(
            "mo",
            [new mathMLTree.TextNode(group.value.rightDelim)]
          );
          rightOp.setAttribute("fence", "true");
          withDelims.push(rightOp);
        }
        var outerNode = new mathMLTree.MathNode("mrow", withDelims);
        return outerNode;
      }
      return node;
    };
    groupTypes.array = function(group, options) {
      return new mathMLTree.MathNode(
        "mtable",
        group.value.body.map(function(row) {
          return new mathMLTree.MathNode(
            "mtr",
            row.map(function(cell) {
              return new mathMLTree.MathNode(
                "mtd",
                [buildGroup(cell, options)]
              );
            })
          );
        })
      );
    };
    groupTypes.sqrt = function(group, options) {
      var node;
      if (group.value.index) {
        node = new mathMLTree.MathNode(
          "mroot",
          [
            buildGroup(group.value.body, options),
            buildGroup(group.value.index, options)
          ]
        );
      } else {
        node = new mathMLTree.MathNode(
          "msqrt",
          [buildGroup(group.value.body, options)]
        );
      }
      return node;
    };
    groupTypes.leftright = function(group, options) {
      var inner = buildExpression(group.value.body, options);
      if (group.value.left !== ".") {
        var leftNode = new mathMLTree.MathNode(
          "mo",
          [makeText(group.value.left, group.mode)]
        );
        leftNode.setAttribute("fence", "true");
        inner.unshift(leftNode);
      }
      if (group.value.right !== ".") {
        var rightNode = new mathMLTree.MathNode(
          "mo",
          [makeText(group.value.right, group.mode)]
        );
        rightNode.setAttribute("fence", "true");
        inner.push(rightNode);
      }
      var outerNode = new mathMLTree.MathNode("mrow", inner);
      return outerNode;
    };
    groupTypes.accent = function(group, options) {
      var accentNode = new mathMLTree.MathNode(
        "mo",
        [makeText(group.value.accent, group.mode)]
      );
      var node = new mathMLTree.MathNode(
        "mover",
        [
          buildGroup(group.value.base, options),
          accentNode
        ]
      );
      node.setAttribute("accent", "true");
      return node;
    };
    groupTypes.spacing = function(group) {
      var node;
      if (group.value === "\\ " || group.value === "\\space" || group.value === " " || group.value === "~") {
        node = new mathMLTree.MathNode(
          "mtext",
          [new mathMLTree.TextNode("Â ")]
        );
      } else {
        node = new mathMLTree.MathNode("mspace");
        node.setAttribute(
          "width",
          buildCommon.spacingFunctions[group.value].size
        );
      }
      return node;
    };
    groupTypes.op = function(group) {
      var node;
      if (group.value.symbol) {
        node = new mathMLTree.MathNode(
          "mo",
          [makeText(group.value.body, group.mode)]
        );
      } else {
        node = new mathMLTree.MathNode(
          "mi",
          [new mathMLTree.TextNode(group.value.body.slice(1))]
        );
      }
      return node;
    };
    groupTypes.katex = function(group) {
      var node = new mathMLTree.MathNode(
        "mtext",
        [new mathMLTree.TextNode("KaTeX")]
      );
      return node;
    };
    groupTypes.font = function(group, options) {
      var font = group.value.font;
      return buildGroup(group.value.body, options.withFont(font));
    };
    groupTypes.delimsizing = function(group) {
      var children = [];
      if (group.value.value !== ".") {
        children.push(makeText(group.value.value, group.mode));
      }
      var node = new mathMLTree.MathNode("mo", children);
      if (group.value.delimType === "open" || group.value.delimType === "close") {
        node.setAttribute("fence", "true");
      } else {
        node.setAttribute("fence", "false");
      }
      return node;
    };
    groupTypes.styling = function(group, options) {
      var inner = buildExpression(group.value.value, options);
      var node = new mathMLTree.MathNode("mstyle", inner);
      var styleAttributes = {
        "display": ["0", "true"],
        "text": ["0", "false"],
        "script": ["1", "false"],
        "scriptscript": ["2", "false"]
      };
      var attr = styleAttributes[group.value.style];
      node.setAttribute("scriptlevel", attr[0]);
      node.setAttribute("displaystyle", attr[1]);
      return node;
    };
    groupTypes.sizing = function(group, options) {
      var inner = buildExpression(group.value.value, options);
      var node = new mathMLTree.MathNode("mstyle", inner);
      node.setAttribute(
        "mathsize",
        buildCommon.sizingMultiplier[group.value.size] + "em"
      );
      return node;
    };
    groupTypes.overline = function(group, options) {
      var operator = new mathMLTree.MathNode(
        "mo",
        [new mathMLTree.TextNode("â¾")]
      );
      operator.setAttribute("stretchy", "true");
      var node = new mathMLTree.MathNode(
        "mover",
        [
          buildGroup(group.value.body, options),
          operator
        ]
      );
      node.setAttribute("accent", "true");
      return node;
    };
    groupTypes.underline = function(group, options) {
      var operator = new mathMLTree.MathNode(
        "mo",
        [new mathMLTree.TextNode("â¾")]
      );
      operator.setAttribute("stretchy", "true");
      var node = new mathMLTree.MathNode(
        "munder",
        [
          buildGroup(group.value.body, options),
          operator
        ]
      );
      node.setAttribute("accentunder", "true");
      return node;
    };
    groupTypes.rule = function(group) {
      var node = new mathMLTree.MathNode("mrow");
      return node;
    };
    groupTypes.llap = function(group, options) {
      var node = new mathMLTree.MathNode(
        "mpadded",
        [buildGroup(group.value.body, options)]
      );
      node.setAttribute("lspace", "-1width");
      node.setAttribute("width", "0px");
      return node;
    };
    groupTypes.rlap = function(group, options) {
      var node = new mathMLTree.MathNode(
        "mpadded",
        [buildGroup(group.value.body, options)]
      );
      node.setAttribute("width", "0px");
      return node;
    };
    groupTypes.phantom = function(group, options, prev) {
      var inner = buildExpression(group.value.value, options);
      return new mathMLTree.MathNode("mphantom", inner);
    };
    var buildExpression = function(expression, options) {
      var groups = [];
      for (var i = 0; i < expression.length; i++) {
        var group = expression[i];
        groups.push(buildGroup(group, options));
      }
      return groups;
    };
    var buildGroup = function(group, options) {
      if (!group) {
        return new mathMLTree.MathNode("mrow");
      }
      if (groupTypes[group.type]) {
        return groupTypes[group.type](group, options);
      } else {
        throw new ParseError(
          "Got group of unknown type: '" + group.type + "'"
        );
      }
    };
    var buildMathML = function(tree, texExpression, options) {
      var expression = buildExpression(tree, options);
      var wrapper = new mathMLTree.MathNode("mrow", expression);
      var annotation = new mathMLTree.MathNode(
        "annotation",
        [new mathMLTree.TextNode(texExpression)]
      );
      annotation.setAttribute("encoding", "application/x-tex");
      var semantics = new mathMLTree.MathNode(
        "semantics",
        [wrapper, annotation]
      );
      var math = new mathMLTree.MathNode("math", [semantics]);
      return makeSpan(["katex-mathml"], [math]);
    };
    module.exports = buildMathML;
  }
});

// node_modules/katex/src/Options.js
var require_Options = __commonJS({
  "node_modules/katex/src/Options.js"(exports, module) {
    function Options(data) {
      this.style = data.style;
      this.color = data.color;
      this.size = data.size;
      this.phantom = data.phantom;
      this.font = data.font;
      if (data.parentStyle === void 0) {
        this.parentStyle = data.style;
      } else {
        this.parentStyle = data.parentStyle;
      }
      if (data.parentSize === void 0) {
        this.parentSize = data.size;
      } else {
        this.parentSize = data.parentSize;
      }
    }
    Options.prototype.extend = function(extension) {
      var data = {
        style: this.style,
        size: this.size,
        color: this.color,
        parentStyle: this.style,
        parentSize: this.size,
        phantom: this.phantom,
        font: this.font
      };
      for (var key in extension) {
        if (extension.hasOwnProperty(key)) {
          data[key] = extension[key];
        }
      }
      return new Options(data);
    };
    Options.prototype.withStyle = function(style) {
      return this.extend({
        style
      });
    };
    Options.prototype.withSize = function(size) {
      return this.extend({
        size
      });
    };
    Options.prototype.withColor = function(color) {
      return this.extend({
        color
      });
    };
    Options.prototype.withPhantom = function() {
      return this.extend({
        phantom: true
      });
    };
    Options.prototype.withFont = function(font) {
      return this.extend({
        font
      });
    };
    Options.prototype.reset = function() {
      return this.extend({});
    };
    var colorMap = {
      "katex-blue": "#6495ed",
      "katex-orange": "#ffa500",
      "katex-pink": "#ff00af",
      "katex-red": "#df0030",
      "katex-green": "#28ae7b",
      "katex-gray": "gray",
      "katex-purple": "#9d38bd",
      "katex-blueA": "#c7e9f1",
      "katex-blueB": "#9cdceb",
      "katex-blueC": "#58c4dd",
      "katex-blueD": "#29abca",
      "katex-blueE": "#1c758a",
      "katex-tealA": "#acead7",
      "katex-tealB": "#76ddc0",
      "katex-tealC": "#5cd0b3",
      "katex-tealD": "#55c1a7",
      "katex-tealE": "#49a88f",
      "katex-greenA": "#c9e2ae",
      "katex-greenB": "#a6cf8c",
      "katex-greenC": "#83c167",
      "katex-greenD": "#77b05d",
      "katex-greenE": "#699c52",
      "katex-goldA": "#f7c797",
      "katex-goldB": "#f9b775",
      "katex-goldC": "#f0ac5f",
      "katex-goldD": "#e1a158",
      "katex-goldE": "#c78d46",
      "katex-redA": "#f7a1a3",
      "katex-redB": "#ff8080",
      "katex-redC": "#fc6255",
      "katex-redD": "#e65a4c",
      "katex-redE": "#cf5044",
      "katex-maroonA": "#ecabc1",
      "katex-maroonB": "#ec92ab",
      "katex-maroonC": "#c55f73",
      "katex-maroonD": "#a24d61",
      "katex-maroonE": "#94424f",
      "katex-purpleA": "#caa3e8",
      "katex-purpleB": "#b189c6",
      "katex-purpleC": "#9a72ac",
      "katex-purpleD": "#715582",
      "katex-purpleE": "#644172",
      "katex-mintA": "#f5f9e8",
      "katex-mintB": "#edf2df",
      "katex-mintC": "#e0e5cc",
      "katex-grayA": "#fdfdfd",
      "katex-grayB": "#f7f7f7",
      "katex-grayC": "#eeeeee",
      "katex-grayD": "#dddddd",
      "katex-grayE": "#cccccc",
      "katex-grayF": "#aaaaaa",
      "katex-grayG": "#999999",
      "katex-grayH": "#555555",
      "katex-grayI": "#333333",
      "katex-kaBlue": "#314453",
      "katex-kaGreen": "#639b24"
    };
    Options.prototype.getColor = function() {
      if (this.phantom) {
        return "transparent";
      } else {
        return colorMap[this.color] || this.color;
      }
    };
    module.exports = Options;
  }
});

// node_modules/katex/src/buildTree.js
var require_buildTree = __commonJS({
  "node_modules/katex/src/buildTree.js"(exports, module) {
    var buildHTML = require_buildHTML();
    var buildMathML = require_buildMathML();
    var buildCommon = require_buildCommon();
    var Options = require_Options();
    var Settings = require_Settings();
    var Style = require_Style();
    var makeSpan = buildCommon.makeSpan;
    var buildTree = function(tree, expression, settings) {
      settings = settings || new Settings({});
      var startStyle = Style.TEXT;
      if (settings.displayMode) {
        startStyle = Style.DISPLAY;
      }
      var options = new Options({
        style: startStyle,
        size: "size5"
      });
      var mathMLNode = buildMathML(tree, expression, options);
      var htmlNode = buildHTML(tree, options);
      var katexNode = makeSpan(["katex"], [
        mathMLNode,
        htmlNode
      ]);
      if (settings.displayMode) {
        return makeSpan(["katex-display"], [katexNode]);
      } else {
        return katexNode;
      }
    };
    module.exports = buildTree;
  }
});

// node_modules/katex/src/functions.js
var require_functions = __commonJS({
  "node_modules/katex/src/functions.js"(exports, module) {
    var utils = require_utils();
    var ParseError = require_ParseError();
    function defineFunction(names, props, handler) {
      if (typeof names === "string") {
        names = [names];
      }
      if (typeof props === "number") {
        props = { numArgs: props };
      }
      var data = {
        numArgs: props.numArgs,
        argTypes: props.argTypes,
        greediness: props.greediness === void 0 ? 1 : props.greediness,
        allowedInText: !!props.allowedInText,
        numOptionalArgs: props.numOptionalArgs || 0,
        handler
      };
      for (var i = 0; i < names.length; ++i) {
        module.exports[names[i]] = data;
      }
    }
    defineFunction("\\sqrt", {
      numArgs: 1,
      numOptionalArgs: 1
    }, function(context, args) {
      var index = args[0];
      var body = args[1];
      return {
        type: "sqrt",
        body,
        index
      };
    });
    defineFunction("\\text", {
      numArgs: 1,
      argTypes: ["text"],
      greediness: 2
    }, function(context, args) {
      var body = args[0];
      var inner;
      if (body.type === "ordgroup") {
        inner = body.value;
      } else {
        inner = [body];
      }
      return {
        type: "text",
        body: inner
      };
    });
    defineFunction("\\color", {
      numArgs: 2,
      allowedInText: true,
      greediness: 3,
      argTypes: ["color", "original"]
    }, function(context, args) {
      var color = args[0];
      var body = args[1];
      var inner;
      if (body.type === "ordgroup") {
        inner = body.value;
      } else {
        inner = [body];
      }
      return {
        type: "color",
        color: color.value,
        value: inner
      };
    });
    defineFunction("\\overline", {
      numArgs: 1
    }, function(context, args) {
      var body = args[0];
      return {
        type: "overline",
        body
      };
    });
    defineFunction("\\underline", {
      numArgs: 1
    }, function(context, args) {
      var body = args[0];
      return {
        type: "underline",
        body
      };
    });
    defineFunction("\\rule", {
      numArgs: 2,
      numOptionalArgs: 1,
      argTypes: ["size", "size", "size"]
    }, function(context, args) {
      var shift = args[0];
      var width = args[1];
      var height = args[2];
      return {
        type: "rule",
        shift: shift && shift.value,
        width: width.value,
        height: height.value
      };
    });
    defineFunction("\\KaTeX", {
      numArgs: 0
    }, function(context) {
      return {
        type: "katex"
      };
    });
    defineFunction("\\phantom", {
      numArgs: 1
    }, function(context, args) {
      var body = args[0];
      var inner;
      if (body.type === "ordgroup") {
        inner = body.value;
      } else {
        inner = [body];
      }
      return {
        type: "phantom",
        value: inner
      };
    });
    var delimiterSizes = {
      "\\bigl": { type: "open", size: 1 },
      "\\Bigl": { type: "open", size: 2 },
      "\\biggl": { type: "open", size: 3 },
      "\\Biggl": { type: "open", size: 4 },
      "\\bigr": { type: "close", size: 1 },
      "\\Bigr": { type: "close", size: 2 },
      "\\biggr": { type: "close", size: 3 },
      "\\Biggr": { type: "close", size: 4 },
      "\\bigm": { type: "rel", size: 1 },
      "\\Bigm": { type: "rel", size: 2 },
      "\\biggm": { type: "rel", size: 3 },
      "\\Biggm": { type: "rel", size: 4 },
      "\\big": { type: "textord", size: 1 },
      "\\Big": { type: "textord", size: 2 },
      "\\bigg": { type: "textord", size: 3 },
      "\\Bigg": { type: "textord", size: 4 }
    };
    var delimiters = [
      "(",
      ")",
      "[",
      "\\lbrack",
      "]",
      "\\rbrack",
      "\\{",
      "\\lbrace",
      "\\}",
      "\\rbrace",
      "\\lfloor",
      "\\rfloor",
      "\\lceil",
      "\\rceil",
      "<",
      ">",
      "\\langle",
      "\\rangle",
      "\\lt",
      "\\gt",
      "\\lvert",
      "\\rvert",
      "\\lVert",
      "\\rVert",
      "\\lgroup",
      "\\rgroup",
      "\\lmoustache",
      "\\rmoustache",
      "/",
      "\\backslash",
      "|",
      "\\vert",
      "\\|",
      "\\Vert",
      "\\uparrow",
      "\\Uparrow",
      "\\downarrow",
      "\\Downarrow",
      "\\updownarrow",
      "\\Updownarrow",
      "."
    ];
    var fontAliases = {
      "\\Bbb": "\\mathbb",
      "\\bold": "\\mathbf",
      "\\frak": "\\mathfrak"
    };
    defineFunction([
      "\\blue",
      "\\orange",
      "\\pink",
      "\\red",
      "\\green",
      "\\gray",
      "\\purple",
      "\\blueA",
      "\\blueB",
      "\\blueC",
      "\\blueD",
      "\\blueE",
      "\\tealA",
      "\\tealB",
      "\\tealC",
      "\\tealD",
      "\\tealE",
      "\\greenA",
      "\\greenB",
      "\\greenC",
      "\\greenD",
      "\\greenE",
      "\\goldA",
      "\\goldB",
      "\\goldC",
      "\\goldD",
      "\\goldE",
      "\\redA",
      "\\redB",
      "\\redC",
      "\\redD",
      "\\redE",
      "\\maroonA",
      "\\maroonB",
      "\\maroonC",
      "\\maroonD",
      "\\maroonE",
      "\\purpleA",
      "\\purpleB",
      "\\purpleC",
      "\\purpleD",
      "\\purpleE",
      "\\mintA",
      "\\mintB",
      "\\mintC",
      "\\grayA",
      "\\grayB",
      "\\grayC",
      "\\grayD",
      "\\grayE",
      "\\grayF",
      "\\grayG",
      "\\grayH",
      "\\grayI",
      "\\kaBlue",
      "\\kaGreen"
    ], {
      numArgs: 1,
      allowedInText: true,
      greediness: 3
    }, function(context, args) {
      var body = args[0];
      var atoms;
      if (body.type === "ordgroup") {
        atoms = body.value;
      } else {
        atoms = [body];
      }
      return {
        type: "color",
        color: "katex-" + context.funcName.slice(1),
        value: atoms
      };
    });
    defineFunction([
      "\\arcsin",
      "\\arccos",
      "\\arctan",
      "\\arg",
      "\\cos",
      "\\cosh",
      "\\cot",
      "\\coth",
      "\\csc",
      "\\deg",
      "\\dim",
      "\\exp",
      "\\hom",
      "\\ker",
      "\\lg",
      "\\ln",
      "\\log",
      "\\sec",
      "\\sin",
      "\\sinh",
      "\\tan",
      "\\tanh"
    ], {
      numArgs: 0
    }, function(context) {
      return {
        type: "op",
        limits: false,
        symbol: false,
        body: context.funcName
      };
    });
    defineFunction([
      "\\det",
      "\\gcd",
      "\\inf",
      "\\lim",
      "\\liminf",
      "\\limsup",
      "\\max",
      "\\min",
      "\\Pr",
      "\\sup"
    ], {
      numArgs: 0
    }, function(context) {
      return {
        type: "op",
        limits: true,
        symbol: false,
        body: context.funcName
      };
    });
    defineFunction([
      "\\int",
      "\\iint",
      "\\iiint",
      "\\oint"
    ], {
      numArgs: 0
    }, function(context) {
      return {
        type: "op",
        limits: false,
        symbol: true,
        body: context.funcName
      };
    });
    defineFunction([
      "\\coprod",
      "\\bigvee",
      "\\bigwedge",
      "\\biguplus",
      "\\bigcap",
      "\\bigcup",
      "\\intop",
      "\\prod",
      "\\sum",
      "\\bigotimes",
      "\\bigoplus",
      "\\bigodot",
      "\\bigsqcup",
      "\\smallint"
    ], {
      numArgs: 0
    }, function(context) {
      return {
        type: "op",
        limits: true,
        symbol: true,
        body: context.funcName
      };
    });
    defineFunction([
      "\\dfrac",
      "\\frac",
      "\\tfrac",
      "\\dbinom",
      "\\binom",
      "\\tbinom"
    ], {
      numArgs: 2,
      greediness: 2
    }, function(context, args) {
      var numer = args[0];
      var denom = args[1];
      var hasBarLine;
      var leftDelim = null;
      var rightDelim = null;
      var size = "auto";
      switch (context.funcName) {
        case "\\dfrac":
        case "\\frac":
        case "\\tfrac":
          hasBarLine = true;
          break;
        case "\\dbinom":
        case "\\binom":
        case "\\tbinom":
          hasBarLine = false;
          leftDelim = "(";
          rightDelim = ")";
          break;
        default:
          throw new Error("Unrecognized genfrac command");
      }
      switch (context.funcName) {
        case "\\dfrac":
        case "\\dbinom":
          size = "display";
          break;
        case "\\tfrac":
        case "\\tbinom":
          size = "text";
          break;
      }
      return {
        type: "genfrac",
        numer,
        denom,
        hasBarLine,
        leftDelim,
        rightDelim,
        size
      };
    });
    defineFunction(["\\llap", "\\rlap"], {
      numArgs: 1,
      allowedInText: true
    }, function(context, args) {
      var body = args[0];
      return {
        type: context.funcName.slice(1),
        body
      };
    });
    defineFunction([
      "\\bigl",
      "\\Bigl",
      "\\biggl",
      "\\Biggl",
      "\\bigr",
      "\\Bigr",
      "\\biggr",
      "\\Biggr",
      "\\bigm",
      "\\Bigm",
      "\\biggm",
      "\\Biggm",
      "\\big",
      "\\Big",
      "\\bigg",
      "\\Bigg",
      "\\left",
      "\\right"
    ], {
      numArgs: 1
    }, function(context, args) {
      var delim = args[0];
      if (!utils.contains(delimiters, delim.value)) {
        throw new ParseError(
          "Invalid delimiter: '" + delim.value + "' after '" + context.funcName + "'",
          context.lexer,
          context.positions[1]
        );
      }
      if (context.funcName === "\\left" || context.funcName === "\\right") {
        return {
          type: "leftright",
          value: delim.value
        };
      } else {
        return {
          type: "delimsizing",
          size: delimiterSizes[context.funcName].size,
          delimType: delimiterSizes[context.funcName].type,
          value: delim.value
        };
      }
    });
    defineFunction([
      "\\tiny",
      "\\scriptsize",
      "\\footnotesize",
      "\\small",
      "\\normalsize",
      "\\large",
      "\\Large",
      "\\LARGE",
      "\\huge",
      "\\Huge"
    ], 0, null);
    defineFunction([
      "\\displaystyle",
      "\\textstyle",
      "\\scriptstyle",
      "\\scriptscriptstyle"
    ], 0, null);
    defineFunction([
      // styles
      "\\mathrm",
      "\\mathit",
      "\\mathbf",
      // families
      "\\mathbb",
      "\\mathcal",
      "\\mathfrak",
      "\\mathscr",
      "\\mathsf",
      "\\mathtt",
      // aliases
      "\\Bbb",
      "\\bold",
      "\\frak"
    ], {
      numArgs: 1,
      greediness: 2
    }, function(context, args) {
      var body = args[0];
      var func = context.funcName;
      if (func in fontAliases) {
        func = fontAliases[func];
      }
      return {
        type: "font",
        font: func.slice(1),
        body
      };
    });
    defineFunction([
      "\\acute",
      "\\grave",
      "\\ddot",
      "\\tilde",
      "\\bar",
      "\\breve",
      "\\check",
      "\\hat",
      "\\vec",
      "\\dot"
      // We don't support expanding accents yet
      // "\\widetilde", "\\widehat"
    ], {
      numArgs: 1
    }, function(context, args) {
      var base = args[0];
      return {
        type: "accent",
        accent: context.funcName,
        base
      };
    });
    defineFunction(["\\over", "\\choose"], {
      numArgs: 0
    }, function(context) {
      var replaceWith;
      switch (context.funcName) {
        case "\\over":
          replaceWith = "\\frac";
          break;
        case "\\choose":
          replaceWith = "\\binom";
          break;
        default:
          throw new Error("Unrecognized infix genfrac command");
      }
      return {
        type: "infix",
        replaceWith
      };
    });
    defineFunction(["\\\\", "\\cr"], {
      numArgs: 0,
      numOptionalArgs: 1,
      argTypes: ["size"]
    }, function(context, args) {
      var size = args[0];
      return {
        type: "cr",
        size
      };
    });
    defineFunction(["\\begin", "\\end"], {
      numArgs: 1,
      argTypes: ["text"]
    }, function(context, args) {
      var nameGroup = args[0];
      if (nameGroup.type !== "ordgroup") {
        throw new ParseError(
          "Invalid environment name",
          context.lexer,
          context.positions[1]
        );
      }
      var name = "";
      for (var i = 0; i < nameGroup.value.length; ++i) {
        name += nameGroup.value[i].value;
      }
      return {
        type: "environment",
        name,
        namepos: context.positions[1]
      };
    });
  }
});

// node_modules/katex/src/parseData.js
var require_parseData = __commonJS({
  "node_modules/katex/src/parseData.js"(exports, module) {
    function ParseNode(type, value, mode) {
      this.type = type;
      this.value = value;
      this.mode = mode;
    }
    module.exports = {
      ParseNode
    };
  }
});

// node_modules/katex/src/environments.js
var require_environments = __commonJS({
  "node_modules/katex/src/environments.js"(exports, module) {
    var fontMetrics = require_fontMetrics();
    var parseData = require_parseData();
    var ParseError = require_ParseError();
    var ParseNode = parseData.ParseNode;
    function parseArray(parser, result) {
      var row = [];
      var body = [row];
      var rowGaps = [];
      while (true) {
        var cell = parser.parseExpression(false, null);
        row.push(new ParseNode("ordgroup", cell, parser.mode));
        var next = parser.nextToken.text;
        if (next === "&") {
          parser.consume();
        } else if (next === "\\end") {
          break;
        } else if (next === "\\\\" || next === "\\cr") {
          var cr = parser.parseFunction();
          rowGaps.push(cr.value.size);
          row = [];
          body.push(row);
        } else {
          var pos = Math.min(parser.pos + 1, parser.lexer._input.length);
          throw new ParseError(
            "Expected & or \\\\ or \\end",
            parser.lexer,
            pos
          );
        }
      }
      result.body = body;
      result.rowGaps = rowGaps;
      return new ParseNode(result.type, result, parser.mode);
    }
    function defineEnvironment(names, props, handler) {
      if (typeof names === "string") {
        names = [names];
      }
      if (typeof props === "number") {
        props = { numArgs: props };
      }
      var data = {
        numArgs: props.numArgs || 0,
        argTypes: props.argTypes,
        greediness: 1,
        allowedInText: !!props.allowedInText,
        numOptionalArgs: props.numOptionalArgs || 0,
        handler
      };
      for (var i = 0; i < names.length; ++i) {
        module.exports[names[i]] = data;
      }
    }
    defineEnvironment("array", {
      numArgs: 1
    }, function(context, args) {
      var colalign = args[0];
      colalign = colalign.value.map ? colalign.value : [colalign];
      var cols = colalign.map(function(node) {
        var ca = node.value;
        if ("lcr".indexOf(ca) !== -1) {
          return {
            type: "align",
            align: ca
          };
        } else if (ca === "|") {
          return {
            type: "separator",
            separator: "|"
          };
        }
        throw new ParseError(
          "Unknown column alignment: " + node.value,
          context.lexer,
          context.positions[1]
        );
      });
      var res = {
        type: "array",
        cols,
        hskipBeforeAndAfter: true
        // \@preamble in lttab.dtx
      };
      res = parseArray(context.parser, res);
      return res;
    });
    defineEnvironment([
      "matrix",
      "pmatrix",
      "bmatrix",
      "Bmatrix",
      "vmatrix",
      "Vmatrix"
    ], {}, function(context) {
      var delimiters = {
        "matrix": null,
        "pmatrix": ["(", ")"],
        "bmatrix": ["[", "]"],
        "Bmatrix": ["\\{", "\\}"],
        "vmatrix": ["|", "|"],
        "Vmatrix": ["\\Vert", "\\Vert"]
      }[context.envName];
      var res = {
        type: "array",
        hskipBeforeAndAfter: false
        // \hskip -\arraycolsep in amsmath
      };
      res = parseArray(context.parser, res);
      if (delimiters) {
        res = new ParseNode("leftright", {
          body: [res],
          left: delimiters[0],
          right: delimiters[1]
        }, context.mode);
      }
      return res;
    });
    defineEnvironment("cases", {}, function(context) {
      var res = {
        type: "array",
        arraystretch: 1.2,
        cols: [{
          type: "align",
          align: "l",
          pregap: 0,
          postgap: fontMetrics.metrics.quad
        }, {
          type: "align",
          align: "l",
          pregap: 0,
          postgap: 0
        }]
      };
      res = parseArray(context.parser, res);
      res = new ParseNode("leftright", {
        body: [res],
        left: "\\{",
        right: "."
      }, context.mode);
      return res;
    });
    defineEnvironment("aligned", {}, function(context) {
      var res = {
        type: "array",
        cols: []
      };
      res = parseArray(context.parser, res);
      var emptyGroup = new ParseNode("ordgroup", [], context.mode);
      var numCols = 0;
      res.value.body.forEach(function(row) {
        var i2;
        for (i2 = 1; i2 < row.length; i2 += 2) {
          row[i2].value.unshift(emptyGroup);
        }
        if (numCols < row.length) {
          numCols = row.length;
        }
      });
      for (var i = 0; i < numCols; ++i) {
        var align = "r";
        var pregap = 0;
        if (i % 2 === 1) {
          align = "l";
        } else if (i > 0) {
          pregap = 2;
        }
        res.value.cols[i] = {
          type: "align",
          align,
          pregap,
          postgap: 0
        };
      }
      return res;
    });
  }
});

// node_modules/match-at/lib/matchAt.js
var require_matchAt = __commonJS({
  "node_modules/match-at/lib/matchAt.js"(exports, module) {
    function getRelocatable(re) {
      if (!re.__matchAtRelocatable) {
        var source = re.source + "|()";
        var flags = "g" + (re.ignoreCase ? "i" : "") + (re.multiline ? "m" : "") + (re.unicode ? "u" : "");
        re.__matchAtRelocatable = new RegExp(source, flags);
      }
      return re.__matchAtRelocatable;
    }
    function matchAt(re, str, pos) {
      if (re.global || re.sticky) {
        throw new Error("matchAt(...): Only non-global regexes are supported");
      }
      var reloc = getRelocatable(re);
      reloc.lastIndex = pos;
      var match = reloc.exec(str);
      if (match[match.length - 1] == null) {
        match.length = match.length - 1;
        return match;
      } else {
        return null;
      }
    }
    module.exports = matchAt;
  }
});

// node_modules/katex/src/Lexer.js
var require_Lexer = __commonJS({
  "node_modules/katex/src/Lexer.js"(exports, module) {
    var matchAt = require_matchAt();
    var ParseError = require_ParseError();
    function Lexer(input) {
      this._input = input;
    }
    function Token(text, data, position) {
      this.text = text;
      this.data = data;
      this.position = position;
    }
    var tokenRegex = new RegExp(
      "([ \r\n	]+)|(---?|[!-\\[\\]-â§âª-í¿ï¤-ï¿¿]|[\uD800-\uDBFF][\uDC00-\uDFFF]|\\\\(?:[a-zA-Z]+|[^\uD800-\uDFFF]))"
    );
    var whitespaceRegex = /\s*/;
    Lexer.prototype._innerLex = function(pos, ignoreWhitespace) {
      var input = this._input;
      if (pos === input.length) {
        return new Token("EOF", null, pos);
      }
      var match = matchAt(tokenRegex, input, pos);
      if (match === null) {
        throw new ParseError(
          "Unexpected character: '" + input[pos] + "'",
          this,
          pos
        );
      } else if (match[2]) {
        return new Token(match[2], null, pos + match[2].length);
      } else if (ignoreWhitespace) {
        return this._innerLex(pos + match[1].length, true);
      } else {
        return new Token(" ", null, pos + match[1].length);
      }
    };
    var cssColor = /#[a-z0-9]+|[a-z]+/i;
    Lexer.prototype._innerLexColor = function(pos) {
      var input = this._input;
      var whitespace = matchAt(whitespaceRegex, input, pos)[0];
      pos += whitespace.length;
      var match;
      if (match = matchAt(cssColor, input, pos)) {
        return new Token(match[0], null, pos + match[0].length);
      } else {
        throw new ParseError("Invalid color", this, pos);
      }
    };
    var sizeRegex = /(-?)\s*(\d+(?:\.\d*)?|\.\d+)\s*([a-z]{2})/;
    Lexer.prototype._innerLexSize = function(pos) {
      var input = this._input;
      var whitespace = matchAt(whitespaceRegex, input, pos)[0];
      pos += whitespace.length;
      var match;
      if (match = matchAt(sizeRegex, input, pos)) {
        var unit = match[3];
        if (unit !== "em" && unit !== "ex") {
          throw new ParseError("Invalid unit: '" + unit + "'", this, pos);
        }
        return new Token(match[0], {
          number: +(match[1] + match[2]),
          unit
        }, pos + match[0].length);
      }
      throw new ParseError("Invalid size", this, pos);
    };
    Lexer.prototype._innerLexWhitespace = function(pos) {
      var input = this._input;
      var whitespace = matchAt(whitespaceRegex, input, pos)[0];
      pos += whitespace.length;
      return new Token(whitespace[0], null, pos);
    };
    Lexer.prototype.lex = function(pos, mode) {
      if (mode === "math") {
        return this._innerLex(pos, true);
      } else if (mode === "text") {
        return this._innerLex(pos, false);
      } else if (mode === "color") {
        return this._innerLexColor(pos);
      } else if (mode === "size") {
        return this._innerLexSize(pos);
      } else if (mode === "whitespace") {
        return this._innerLexWhitespace(pos);
      }
    };
    module.exports = Lexer;
  }
});

// node_modules/katex/src/Parser.js
var require_Parser = __commonJS({
  "node_modules/katex/src/Parser.js"(exports, module) {
    var functions = require_functions();
    var environments = require_environments();
    var Lexer = require_Lexer();
    var symbols = require_symbols();
    var utils = require_utils();
    var parseData = require_parseData();
    var ParseError = require_ParseError();
    function Parser(input, settings) {
      this.lexer = new Lexer(input);
      this.settings = settings;
    }
    var ParseNode = parseData.ParseNode;
    function ParseFuncOrArgument(result, isFunction) {
      this.result = result;
      this.isFunction = isFunction;
    }
    Parser.prototype.expect = function(text, consume) {
      if (this.nextToken.text !== text) {
        throw new ParseError(
          "Expected '" + text + "', got '" + this.nextToken.text + "'",
          this.lexer,
          this.nextToken.position
        );
      }
      if (consume !== false) {
        this.consume();
      }
    };
    Parser.prototype.consume = function() {
      this.pos = this.nextToken.position;
      this.nextToken = this.lexer.lex(this.pos, this.mode);
    };
    Parser.prototype.parse = function() {
      this.mode = "math";
      this.pos = 0;
      this.nextToken = this.lexer.lex(this.pos, this.mode);
      var parse = this.parseInput();
      return parse;
    };
    Parser.prototype.parseInput = function() {
      var expression = this.parseExpression(false);
      this.expect("EOF", false);
      return expression;
    };
    var endOfExpression = ["}", "\\end", "\\right", "&", "\\\\", "\\cr"];
    Parser.prototype.parseExpression = function(breakOnInfix, breakOnToken) {
      var body = [];
      while (true) {
        var lex = this.nextToken;
        var pos = this.pos;
        if (endOfExpression.indexOf(lex.text) !== -1) {
          break;
        }
        if (breakOnToken && lex.text === breakOnToken) {
          break;
        }
        var atom = this.parseAtom();
        if (!atom) {
          if (!this.settings.throwOnError && lex.text[0] === "\\") {
            var errorNode = this.handleUnsupportedCmd();
            body.push(errorNode);
            pos = lex.position;
            continue;
          }
          break;
        }
        if (breakOnInfix && atom.type === "infix") {
          this.pos = pos;
          this.nextToken = lex;
          break;
        }
        body.push(atom);
      }
      return this.handleInfixNodes(body);
    };
    Parser.prototype.handleInfixNodes = function(body) {
      var overIndex = -1;
      var funcName;
      for (var i = 0; i < body.length; i++) {
        var node = body[i];
        if (node.type === "infix") {
          if (overIndex !== -1) {
            throw new ParseError(
              "only one infix operator per group",
              this.lexer,
              -1
            );
          }
          overIndex = i;
          funcName = node.value.replaceWith;
        }
      }
      if (overIndex !== -1) {
        var numerNode;
        var denomNode;
        var numerBody = body.slice(0, overIndex);
        var denomBody = body.slice(overIndex + 1);
        if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
          numerNode = numerBody[0];
        } else {
          numerNode = new ParseNode("ordgroup", numerBody, this.mode);
        }
        if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
          denomNode = denomBody[0];
        } else {
          denomNode = new ParseNode("ordgroup", denomBody, this.mode);
        }
        var value = this.callFunction(
          funcName,
          [numerNode, denomNode],
          null
        );
        return [new ParseNode(value.type, value, this.mode)];
      } else {
        return body;
      }
    };
    var SUPSUB_GREEDINESS = 1;
    Parser.prototype.handleSupSubscript = function(name) {
      var symbol = this.nextToken.text;
      var symPos = this.pos;
      this.consume();
      var group = this.parseGroup();
      if (!group) {
        if (!this.settings.throwOnError && this.nextToken.text[0] === "\\") {
          return this.handleUnsupportedCmd();
        } else {
          throw new ParseError(
            "Expected group after '" + symbol + "'",
            this.lexer,
            symPos + 1
          );
        }
      } else if (group.isFunction) {
        var funcGreediness = functions[group.result].greediness;
        if (funcGreediness > SUPSUB_GREEDINESS) {
          return this.parseFunction(group);
        } else {
          throw new ParseError(
            "Got function '" + group.result + "' with no arguments as " + name,
            this.lexer,
            symPos + 1
          );
        }
      } else {
        return group.result;
      }
    };
    Parser.prototype.handleUnsupportedCmd = function() {
      var text = this.nextToken.text;
      var textordArray = [];
      for (var i = 0; i < text.length; i++) {
        textordArray.push(new ParseNode("textord", text[i], "text"));
      }
      var textNode = new ParseNode(
        "text",
        {
          body: textordArray,
          type: "text"
        },
        this.mode
      );
      var colorNode = new ParseNode(
        "color",
        {
          color: this.settings.errorColor,
          value: [textNode],
          type: "color"
        },
        this.mode
      );
      this.consume();
      return colorNode;
    };
    Parser.prototype.parseAtom = function() {
      var base = this.parseImplicitGroup();
      if (this.mode === "text") {
        return base;
      }
      var superscript;
      var subscript;
      while (true) {
        var lex = this.nextToken;
        if (lex.text === "\\limits" || lex.text === "\\nolimits") {
          if (!base || base.type !== "op") {
            throw new ParseError(
              "Limit controls must follow a math operator",
              this.lexer,
              this.pos
            );
          } else {
            var limits = lex.text === "\\limits";
            base.value.limits = limits;
            base.value.alwaysHandleSupSub = true;
          }
          this.consume();
        } else if (lex.text === "^") {
          if (superscript) {
            throw new ParseError(
              "Double superscript",
              this.lexer,
              this.pos
            );
          }
          superscript = this.handleSupSubscript("superscript");
        } else if (lex.text === "_") {
          if (subscript) {
            throw new ParseError(
              "Double subscript",
              this.lexer,
              this.pos
            );
          }
          subscript = this.handleSupSubscript("subscript");
        } else if (lex.text === "'") {
          var prime = new ParseNode("textord", "\\prime", this.mode);
          var primes = [prime];
          this.consume();
          while (this.nextToken.text === "'") {
            primes.push(prime);
            this.consume();
          }
          superscript = new ParseNode("ordgroup", primes, this.mode);
        } else {
          break;
        }
      }
      if (superscript || subscript) {
        return new ParseNode("supsub", {
          base,
          sup: superscript,
          sub: subscript
        }, this.mode);
      } else {
        return base;
      }
    };
    var sizeFuncs = [
      "\\tiny",
      "\\scriptsize",
      "\\footnotesize",
      "\\small",
      "\\normalsize",
      "\\large",
      "\\Large",
      "\\LARGE",
      "\\huge",
      "\\Huge"
    ];
    var styleFuncs = [
      "\\displaystyle",
      "\\textstyle",
      "\\scriptstyle",
      "\\scriptscriptstyle"
    ];
    Parser.prototype.parseImplicitGroup = function() {
      var start = this.parseSymbol();
      if (start == null) {
        return this.parseFunction();
      }
      var func = start.result;
      var body;
      if (func === "\\left") {
        var left = this.parseFunction(start);
        body = this.parseExpression(false);
        this.expect("\\right", false);
        var right = this.parseFunction();
        return new ParseNode("leftright", {
          body,
          left: left.value.value,
          right: right.value.value
        }, this.mode);
      } else if (func === "\\begin") {
        var begin = this.parseFunction(start);
        var envName = begin.value.name;
        if (!environments.hasOwnProperty(envName)) {
          throw new ParseError(
            "No such environment: " + envName,
            this.lexer,
            begin.value.namepos
          );
        }
        var env = environments[envName];
        var args = this.parseArguments("\\begin{" + envName + "}", env);
        var context = {
          mode: this.mode,
          envName,
          parser: this,
          lexer: this.lexer,
          positions: args.pop()
        };
        var result = env.handler(context, args);
        this.expect("\\end", false);
        var end = this.parseFunction();
        if (end.value.name !== envName) {
          throw new ParseError(
            "Mismatch: \\begin{" + envName + "} matched by \\end{" + end.value.name + "}",
            this.lexer
            /* , end.value.namepos */
          );
        }
        result.position = end.position;
        return result;
      } else if (utils.contains(sizeFuncs, func)) {
        body = this.parseExpression(false);
        return new ParseNode("sizing", {
          // Figure out what size to use based on the list of functions above
          size: "size" + (utils.indexOf(sizeFuncs, func) + 1),
          value: body
        }, this.mode);
      } else if (utils.contains(styleFuncs, func)) {
        body = this.parseExpression(true);
        return new ParseNode("styling", {
          // Figure out what style to use by pulling out the style from
          // the function name
          style: func.slice(1, func.length - 5),
          value: body
        }, this.mode);
      } else {
        return this.parseFunction(start);
      }
    };
    Parser.prototype.parseFunction = function(baseGroup) {
      if (!baseGroup) {
        baseGroup = this.parseGroup();
      }
      if (baseGroup) {
        if (baseGroup.isFunction) {
          var func = baseGroup.result;
          var funcData = functions[func];
          if (this.mode === "text" && !funcData.allowedInText) {
            throw new ParseError(
              "Can't use function '" + func + "' in text mode",
              this.lexer,
              baseGroup.position
            );
          }
          var args = this.parseArguments(func, funcData);
          var result = this.callFunction(func, args, args.pop());
          return new ParseNode(result.type, result, this.mode);
        } else {
          return baseGroup.result;
        }
      } else {
        return null;
      }
    };
    Parser.prototype.callFunction = function(name, args, positions) {
      var context = {
        funcName: name,
        parser: this,
        lexer: this.lexer,
        positions
      };
      return functions[name].handler(context, args);
    };
    Parser.prototype.parseArguments = function(func, funcData) {
      var totalArgs = funcData.numArgs + funcData.numOptionalArgs;
      if (totalArgs === 0) {
        return [[this.pos]];
      }
      var baseGreediness = funcData.greediness;
      var positions = [this.pos];
      var args = [];
      for (var i = 0; i < totalArgs; i++) {
        var argType = funcData.argTypes && funcData.argTypes[i];
        var arg;
        if (i < funcData.numOptionalArgs) {
          if (argType) {
            arg = this.parseSpecialGroup(argType, true);
          } else {
            arg = this.parseOptionalGroup();
          }
          if (!arg) {
            args.push(null);
            positions.push(this.pos);
            continue;
          }
        } else {
          if (argType) {
            arg = this.parseSpecialGroup(argType);
          } else {
            arg = this.parseGroup();
          }
          if (!arg) {
            if (!this.settings.throwOnError && this.nextToken.text[0] === "\\") {
              arg = new ParseFuncOrArgument(
                this.handleUnsupportedCmd(this.nextToken.text),
                false
              );
            } else {
              throw new ParseError(
                "Expected group after '" + func + "'",
                this.lexer,
                this.pos
              );
            }
          }
        }
        var argNode;
        if (arg.isFunction) {
          var argGreediness = functions[arg.result].greediness;
          if (argGreediness > baseGreediness) {
            argNode = this.parseFunction(arg);
          } else {
            throw new ParseError(
              "Got function '" + arg.result + "' as argument to '" + func + "'",
              this.lexer,
              this.pos - 1
            );
          }
        } else {
          argNode = arg.result;
        }
        args.push(argNode);
        positions.push(this.pos);
      }
      args.push(positions);
      return args;
    };
    Parser.prototype.parseSpecialGroup = function(innerMode, optional) {
      var outerMode = this.mode;
      if (innerMode === "original") {
        innerMode = outerMode;
      }
      if (innerMode === "color" || innerMode === "size") {
        var openBrace = this.nextToken;
        if (optional && openBrace.text !== "[") {
          return null;
        }
        this.mode = innerMode;
        this.expect(optional ? "[" : "{");
        var inner = this.nextToken;
        this.mode = outerMode;
        var data;
        if (innerMode === "color") {
          data = inner.text;
        } else {
          data = inner.data;
        }
        this.consume();
        this.expect(optional ? "]" : "}");
        return new ParseFuncOrArgument(
          new ParseNode(innerMode, data, outerMode),
          false
        );
      } else if (innerMode === "text") {
        var whitespace = this.lexer.lex(this.pos, "whitespace");
        this.pos = whitespace.position;
      }
      this.mode = innerMode;
      this.nextToken = this.lexer.lex(this.pos, innerMode);
      var res;
      if (optional) {
        res = this.parseOptionalGroup();
      } else {
        res = this.parseGroup();
      }
      this.mode = outerMode;
      this.nextToken = this.lexer.lex(this.pos, outerMode);
      return res;
    };
    Parser.prototype.parseGroup = function() {
      if (this.nextToken.text === "{") {
        this.consume();
        var expression = this.parseExpression(false);
        this.expect("}");
        return new ParseFuncOrArgument(
          new ParseNode("ordgroup", expression, this.mode),
          false
        );
      } else {
        return this.parseSymbol();
      }
    };
    Parser.prototype.parseOptionalGroup = function() {
      if (this.nextToken.text === "[") {
        this.consume();
        var expression = this.parseExpression(false, "]");
        this.expect("]");
        return new ParseFuncOrArgument(
          new ParseNode("ordgroup", expression, this.mode),
          false
        );
      } else {
        return null;
      }
    };
    Parser.prototype.parseSymbol = function() {
      var nucleus = this.nextToken;
      if (functions[nucleus.text]) {
        this.consume();
        return new ParseFuncOrArgument(
          nucleus.text,
          true
        );
      } else if (symbols[this.mode][nucleus.text]) {
        this.consume();
        return new ParseFuncOrArgument(
          new ParseNode(
            symbols[this.mode][nucleus.text].group,
            nucleus.text,
            this.mode
          ),
          false
        );
      } else {
        return null;
      }
    };
    Parser.prototype.ParseNode = ParseNode;
    module.exports = Parser;
  }
});

// node_modules/katex/src/parseTree.js
var require_parseTree = __commonJS({
  "node_modules/katex/src/parseTree.js"(exports, module) {
    var Parser = require_Parser();
    var parseTree = function(toParse, settings) {
      var parser = new Parser(toParse, settings);
      return parser.parse();
    };
    module.exports = parseTree;
  }
});

// node_modules/katex/katex.js
var require_katex = __commonJS({
  "node_modules/katex/katex.js"(exports, module) {
    var ParseError = require_ParseError();
    var Settings = require_Settings();
    var buildTree = require_buildTree();
    var parseTree = require_parseTree();
    var utils = require_utils();
    var render = function(expression, baseNode, options) {
      utils.clearNode(baseNode);
      var settings = new Settings(options);
      var tree = parseTree(expression, settings);
      var node = buildTree(tree, expression, settings).toNode();
      baseNode.appendChild(node);
    };
    if (typeof document !== "undefined") {
      if (document.compatMode !== "CSS1Compat") {
        typeof console !== "undefined" && console.warn(
          "Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype."
        );
        render = function() {
          throw new ParseError("KaTeX doesn't work in quirks mode.");
        };
      }
    }
    var renderToString = function(expression, options) {
      var settings = new Settings(options);
      var tree = parseTree(expression, settings);
      return buildTree(tree, expression, settings).toMarkup();
    };
    var generateParseTree = function(expression, options) {
      var settings = new Settings(options);
      return parseTree(expression, settings);
    };
    module.exports = {
      render,
      renderToString,
      /**
       * NOTE: This method is not currently recommended for public use.
       * The internal tree representation is unstable and is very likely
       * to change. Use at your own risk.
       */
      __parse: generateParseTree,
      ParseError
    };
  }
});
export default require_katex();
//# sourceMappingURL=katex.js.map
